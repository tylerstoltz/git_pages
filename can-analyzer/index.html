<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAN Bus Analyzer - Code Tools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2d2d30;
            padding: 15px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 500;
            color: #569cd6;
        }

        .back-link {
            color: #569cd6;
            text-decoration: none;
            font-size: 14px;
            transition: color 0.2s;
        }

        .back-link:hover {
            color: #4ec9b0;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 51px);
            padding: 20px;
            gap: 15px;
            overflow: hidden;
        }

        .input-section {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #3e3e42;
            flex-shrink: 0;
        }

        .section-title {
            font-size: 14px;
            color: #4ec9b0;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        textarea {
            width: 100%;
            background: #2d2d30;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            line-height: 1.5;
            min-height: 120px;
        }

        textarea:focus {
            outline: none;
            border-color: #569cd6;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        button {
            background: #0e639c;
            color: #ffffff;
            border: none;
            padding: 8px 14px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        button:hover {
            background: #1177bb;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #3c3c3c;
        }

        button.secondary:hover {
            background: #4a4a4a;
        }

        .output-section {
            flex: 1;
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #3e3e42;
            overflow-y: auto;
        }

        .message-card {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.2s;
        }

        .message-card:hover {
            border-color: #569cd6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3e3e42;
        }

        .message-id {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: 600;
            color: #4ec9b0;
        }

        .message-type {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 3px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .type-standard {
            background: #0e639c;
            color: white;
        }

        .type-extended {
            background: #c586c0;
            color: white;
        }

        .message-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .detail-item {
            display: flex;
            gap: 8px;
        }

        .detail-label {
            color: #858585;
            font-size: 12px;
        }

        .detail-value {
            color: #569cd6;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: 600;
        }

        .data-section {
            margin-top: 10px;
        }

        .data-label {
            color: #858585;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .data-display {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .data-row {
            display: flex;
            gap: 15px;
            margin-bottom: 4px;
        }

        .data-hex {
            color: #ce9178;
        }

        .data-dec {
            color: #b5cea8;
        }

        .data-ascii {
            color: #9cdcfe;
        }

        .error-message {
            background: #3e1e1e;
            border: 1px solid #f48771;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 12px;
            color: #f48771;
            font-size: 13px;
        }

        .info-section {
            background: #252526;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #3e3e42;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
            flex-shrink: 0;
        }

        .info-section code {
            background: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #ce9178;
        }

        .info-section ul {
            margin-left: 20px;
            margin-top: 8px;
        }

        .info-section li {
            margin-bottom: 4px;
        }

        .stats {
            background: #252526;
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
            font-size: 12px;
            color: #858585;
            display: flex;
            gap: 20px;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            gap: 5px;
        }

        .stat-value {
            color: #4ec9b0;
            font-weight: 600;
        }

        .empty-state {
            text-align: center;
            color: #858585;
            padding: 40px;
            font-size: 14px;
        }

        .mapping-section {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #3e3e42;
            flex-shrink: 0;
        }

        .mapping-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 1px solid #3e3e42;
        }

        .tab-button {
            background: transparent;
            color: #858585;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-button:hover {
            color: #d4d4d4;
            background: transparent;
            transform: none;
        }

        .tab-button.active {
            color: #4ec9b0;
            border-bottom-color: #4ec9b0;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .mapped-data {
            background: #1a3a1a;
            border: 1px solid #4ec9b0;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
        }

        .mapped-name {
            color: #4ec9b0;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .signal-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #3e3e42;
        }

        .signal-row:last-child {
            border-bottom: none;
        }

        .signal-name {
            color: #9cdcfe;
            font-size: 12px;
        }

        .signal-value {
            color: #b5cea8;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: 600;
        }

        .mapping-status {
            background: #1e3a1e;
            border: 1px solid #4ec9b0;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 10px;
            font-size: 12px;
            color: #4ec9b0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .message-details {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöó CAN Bus Protocol Analyzer</h1>
        <a href="../" class="back-link">‚Üê Back to Tools</a>
    </div>

    <div class="container">
        <div class="info-section">
            <div class="section-title" style="margin-bottom: 8px;">Supported Formats</div>
            <p>Enter CAN bus messages in one of the following formats:</p>
            <ul>
                <li><code>123#1122334455667788</code> - Standard format: ID#DATA</li>
                <li><code>1FFFFFFF#1122334455667788</code> - Extended format: ID#DATA</li>
                <li><code>0x123#0x11 0x22 0x33</code> - With 0x prefix and spaces</li>
                <li><code>candump format: (1234.567) can0 123#1122334455</code></li>
            </ul>
            <p style="margin-top: 8px;">Each line represents one CAN message. Data bytes are in hexadecimal format.</p>
        </div>

        <div class="input-section">
            <div class="section-title">Input CAN Messages</div>
            <textarea id="input" placeholder="Enter CAN messages here, one per line...
Example:
123#0102030405060708
1FFFFFFF#DEADBEEF
0x456#0x11 0x22 0x33"></textarea>
            <div class="buttons">
                <button onclick="parseMessages()">üîç Parse Messages</button>
                <button class="secondary" onclick="loadExample()">üìù Load Example</button>
                <button class="secondary" onclick="clearAll()">üóëÔ∏è Clear All</button>
            </div>
        </div>

        <div class="mapping-section">
            <div class="section-title">Message Mapping (Optional)</div>
            <div class="mapping-tabs">
                <button class="tab-button active" onclick="switchTab('json')">JSON Config</button>
                <button class="tab-button" onclick="switchTab('dbc')">DBC File</button>
            </div>

            <div id="tab-json" class="tab-content active">
                <textarea id="mappingInput" placeholder='Enter mapping configuration in JSON format:
{
  "0x123": {
    "name": "EngineData",
    "signals": [
      {
        "name": "Temperature",
        "startByte": 1,
        "length": 1,
        "offset": 30,
        "scale": 1,
        "endianness": "big"
      },
      {
        "name": "RPM",
        "startByte": 2,
        "length": 1,
        "offset": 0,
        "scale": 1,
        "endianness": "big"
      }
    ]
  }
}' style="min-height: 150px;"></textarea>
                <div class="buttons">
                    <button onclick="applyMapping()">‚úì Apply Mapping</button>
                    <button class="secondary" onclick="loadMappingExample()">üìù Load Example</button>
                    <button class="secondary" onclick="clearMapping()">‚úó Clear Mapping</button>
                </div>
            </div>

            <div id="tab-dbc" class="tab-content">
                <textarea id="dbcInput" placeholder='Paste DBC file content here or upload a file:

BO_ 291 EngineData: 8 ECU
 SG_ Temperature : 8|8@1+ (1,30) [0|0] "C"  Receiver
 SG_ RPM : 16|8@1+ (1,0) [0|0] "rpm"  Receiver

BO_ 1122 SpeedData: 8 ECU
 SG_ VehicleSpeed : 0|16@1+ (0.01,0) [0|300] "km/h"  Receiver' style="min-height: 150px;"></textarea>
                <div class="buttons">
                    <button onclick="parseDBC()">‚úì Parse DBC</button>
                    <div class="file-input-wrapper">
                        <button class="secondary">üìÅ Upload DBC File</button>
                        <input type="file" id="dbcFile" accept=".dbc" onchange="handleDBCFile(this)">
                    </div>
                    <button class="secondary" onclick="clearMapping()">‚úó Clear Mapping</button>
                </div>
            </div>

            <div id="mappingStatus" style="display: none;"></div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-item">
                <span>Total Messages:</span>
                <span class="stat-value" id="totalMessages">0</span>
            </div>
            <div class="stat-item">
                <span>Standard (11-bit):</span>
                <span class="stat-value" id="standardCount">0</span>
            </div>
            <div class="stat-item">
                <span>Extended (29-bit):</span>
                <span class="stat-value" id="extendedCount">0</span>
            </div>
            <div class="stat-item">
                <span>Total Bytes:</span>
                <span class="stat-value" id="totalBytes">0</span>
            </div>
        </div>

        <div class="output-section">
            <div class="section-title">Decoded Messages</div>
            <div id="output">
                <div class="empty-state">
                    No messages parsed yet. Enter CAN data above and click "Parse Messages".
                </div>
            </div>
        </div>
    </div>

    <script>
        const input = document.getElementById('input');
        const output = document.getElementById('output');
        const stats = document.getElementById('stats');

        // Global mapping configuration
        let messageMapping = {};

        function parseMessages() {
            const text = input.value.trim();

            if (!text) {
                output.innerHTML = '<div class="empty-state">No input provided. Please enter CAN messages.</div>';
                stats.style.display = 'none';
                return;
            }

            const lines = text.split('\n').filter(line => line.trim());
            const messages = [];
            const errors = [];

            lines.forEach((line, index) => {
                try {
                    const message = parseCANMessage(line.trim());
                    if (message) {
                        messages.push(message);
                    }
                } catch (e) {
                    errors.push({ line: index + 1, message: e.message, raw: line });
                }
            });

            displayMessages(messages, errors);
            updateStats(messages);
        }

        function parseCANMessage(line) {
            // Remove candump timestamp and interface if present
            // Format: (timestamp) interface ID#DATA
            let cleaned = line.replace(/^\([^\)]+\)\s+\w+\s+/, '');

            // Split by # to separate ID and data
            const parts = cleaned.split('#');
            if (parts.length !== 2) {
                throw new Error('Invalid format. Expected ID#DATA');
            }

            // Parse ID
            let id = parts[0].trim().replace(/^0x/i, '');
            if (!/^[0-9A-Fa-f]+$/.test(id)) {
                throw new Error('Invalid ID format');
            }

            const idValue = parseInt(id, 16);
            const isExtended = id.length > 3 || idValue > 0x7FF;

            // Parse data bytes
            let dataStr = parts[1].trim();
            // Remove 0x prefixes and split by spaces or consecutive pairs
            dataStr = dataStr.replace(/0x/gi, '');

            let dataBytes = [];
            if (dataStr.includes(' ')) {
                // Space-separated bytes
                dataBytes = dataStr.split(/\s+/).filter(b => b.length > 0);
            } else {
                // Consecutive hex string
                dataBytes = dataStr.match(/.{1,2}/g) || [];
            }

            // Validate and convert data bytes
            const data = dataBytes.map(byte => {
                if (!/^[0-9A-Fa-f]{1,2}$/.test(byte)) {
                    throw new Error(`Invalid data byte: ${byte}`);
                }
                return parseInt(byte, 16);
            });

            if (data.length > 8) {
                throw new Error('CAN message data cannot exceed 8 bytes');
            }

            return {
                id: idValue,
                idHex: '0x' + idValue.toString(16).toUpperCase(),
                idBin: '0b' + idValue.toString(2).padStart(isExtended ? 29 : 11, '0'),
                isExtended: isExtended,
                dlc: data.length,
                data: data,
                raw: line
            };
        }

        function displayMessages(messages, errors) {
            let html = '';

            // Display errors first
            errors.forEach(error => {
                html += `
                    <div class="error-message">
                        <strong>Line ${error.line} Error:</strong> ${error.message}<br>
                        <code>${escapeHtml(error.raw)}</code>
                    </div>
                `;
            });

            // Display parsed messages
            messages.forEach((msg, index) => {
                const dataHex = msg.data.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join(' ');
                const dataDec = msg.data.map(b => b.toString().padStart(3, ' ')).join(' ');
                const dataAscii = msg.data.map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.').join(' ');

                // Check for message mapping
                const mapping = getMessageMapping(msg);
                let mappedDataHtml = '';

                if (mapping) {
                    let signalsHtml = '';
                    mapping.signals.forEach(signal => {
                        const value = decodeSignal(msg.data, signal);
                        if (value !== null) {
                            signalsHtml += `
                                <div class="signal-row">
                                    <span class="signal-name">${signal.name}:</span>
                                    <span class="signal-value">${value}</span>
                                </div>
                            `;
                        }
                    });

                    if (signalsHtml) {
                        mappedDataHtml = `
                            <div class="mapped-data">
                                <div class="mapped-name">${mapping.name}</div>
                                ${signalsHtml}
                            </div>
                        `;
                    }
                }

                html += `
                    <div class="message-card">
                        <div class="message-header">
                            <div class="message-id">${msg.idHex}${mapping ? ' - ' + mapping.name : ''}</div>
                            <div class="message-type ${msg.isExtended ? 'type-extended' : 'type-standard'}">
                                ${msg.isExtended ? 'Extended (29-bit)' : 'Standard (11-bit)'}
                            </div>
                        </div>

                        <div class="message-details">
                            <div class="detail-item">
                                <span class="detail-label">ID (Hex):</span>
                                <span class="detail-value">${msg.idHex}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">ID (Dec):</span>
                                <span class="detail-value">${msg.id}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">ID (Bin):</span>
                                <span class="detail-value">${msg.idBin}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">DLC:</span>
                                <span class="detail-value">${msg.dlc} byte${msg.dlc !== 1 ? 's' : ''}</span>
                            </div>
                        </div>

                        ${mappedDataHtml}

                        ${msg.data.length > 0 ? `
                            <div class="data-section">
                                <div class="data-label">Data Payload:</div>
                                <div class="data-display">
                                    <div class="data-row">
                                        <span style="color: #858585; min-width: 50px;">HEX:</span>
                                        <span class="data-hex">${dataHex}</span>
                                    </div>
                                    <div class="data-row">
                                        <span style="color: #858585; min-width: 50px;">DEC:</span>
                                        <span class="data-dec">${dataDec}</span>
                                    </div>
                                    <div class="data-row">
                                        <span style="color: #858585; min-width: 50px;">ASCII:</span>
                                        <span class="data-ascii">${dataAscii}</span>
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            if (messages.length === 0 && errors.length === 0) {
                html = '<div class="empty-state">No valid messages found.</div>';
            }

            output.innerHTML = html;
        }

        function updateStats(messages) {
            if (messages.length === 0) {
                stats.style.display = 'none';
                return;
            }

            stats.style.display = 'flex';

            const standardCount = messages.filter(m => !m.isExtended).length;
            const extendedCount = messages.filter(m => m.isExtended).length;
            const totalBytes = messages.reduce((sum, m) => sum + m.dlc, 0);

            document.getElementById('totalMessages').textContent = messages.length;
            document.getElementById('standardCount').textContent = standardCount;
            document.getElementById('extendedCount').textContent = extendedCount;
            document.getElementById('totalBytes').textContent = totalBytes;
        }

        function loadExample() {
            input.value = `# Standard CAN messages (11-bit ID)
# Message 0x123 with Temperature=242¬∞C (0xF2) and RPM=51 (0x33)
123#0011F23300000000
# Same message with Temperature=272¬∞C (0xFF+30 offset) and RPM=51
123#0011FF3300000000
456#DEADBEEF
0x1FF#1122334455
0x100#48656C6C6F

# Extended CAN messages (29-bit ID)
1FFFFFFF#0102030405060708
18FEF100#CAFEBABE
0x1234ABCD#FF00FF00

# candump format
(000000.123456) can0 123#1122334455667788
(000000.234567) vcan0 456#AABBCCDD`;
            parseMessages();
        }

        function clearAll() {
            input.value = '';
            output.innerHTML = '<div class="empty-state">No messages parsed yet. Enter CAN data above and click "Parse Messages".</div>';
            stats.style.display = 'none';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Parse on Enter key
        input.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'Enter') {
                parseMessages();
            }
        });

        // ========== Mapping Functions ==========

        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`tab-${tab}`).classList.add('active');
        }

        function applyMapping() {
            const mappingInput = document.getElementById('mappingInput').value.trim();

            if (!mappingInput) {
                showMappingStatus('No mapping provided', 'error');
                messageMapping = {};
                return;
            }

            try {
                const mapping = JSON.parse(mappingInput);

                // Normalize keys to uppercase hex format
                messageMapping = {};
                for (const [key, value] of Object.entries(mapping)) {
                    const normalizedKey = normalizeHexKey(key);
                    messageMapping[normalizedKey] = value;
                }

                showMappingStatus(`‚úì Mapping loaded for ${Object.keys(messageMapping).length} message(s)`, 'success');

                // Re-parse messages with new mapping
                if (input.value.trim()) {
                    parseMessages();
                }
            } catch (e) {
                showMappingStatus(`Error parsing JSON: ${e.message}`, 'error');
                messageMapping = {};
            }
        }

        function parseDBC() {
            const dbcInput = document.getElementById('dbcInput').value.trim();

            if (!dbcInput) {
                showMappingStatus('No DBC content provided', 'error');
                return;
            }

            try {
                messageMapping = parseDBCContent(dbcInput);
                const msgCount = Object.keys(messageMapping).length;
                const signalCount = Object.values(messageMapping).reduce((sum, msg) => sum + msg.signals.length, 0);

                showMappingStatus(`‚úì DBC parsed: ${msgCount} message(s), ${signalCount} signal(s)`, 'success');

                // Re-parse messages with new mapping
                if (input.value.trim()) {
                    parseMessages();
                }
            } catch (e) {
                showMappingStatus(`Error parsing DBC: ${e.message}`, 'error');
                messageMapping = {};
            }
        }

        function parseDBCContent(dbcContent) {
            const mapping = {};
            const lines = dbcContent.split('\n');

            let currentMessage = null;
            let currentMessageId = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // Parse message definition: BO_ <id> <name>: <dlc> <sender>
                const msgMatch = line.match(/^BO_\s+(\d+)\s+(\w+)\s*:\s*(\d+)\s+(\w+)/);
                if (msgMatch) {
                    const id = parseInt(msgMatch[1]);
                    const name = msgMatch[2];
                    currentMessageId = '0x' + id.toString(16).toUpperCase();
                    currentMessage = {
                        name: name,
                        signals: []
                    };
                    mapping[currentMessageId] = currentMessage;
                    continue;
                }

                // Parse signal definition: SG_ <name> : <start_bit>|<length>@<endianness><signed> (<scale>,<offset>) [<min>|<max>] "<unit>" <receiver>
                const sigMatch = line.match(/^SG_\s+(\w+)\s*:\s*(\d+)\|(\d+)@([01])([+-])\s*\(([^,]+),([^)]+)\)\s*\[([^\]]*)\]\s*"([^"]*)"\s*(.+)/);
                if (sigMatch && currentMessage) {
                    const signalName = sigMatch[1];
                    const startBit = parseInt(sigMatch[2]);
                    const bitLength = parseInt(sigMatch[3]);
                    const endianness = sigMatch[4] === '1' ? 'little' : 'big';
                    const isSigned = sigMatch[5] === '-';
                    const scale = parseFloat(sigMatch[6]);
                    const offset = parseFloat(sigMatch[7]);
                    const unit = sigMatch[9];

                    // Convert bit position to byte position
                    const startByte = Math.floor(startBit / 8);
                    const byteLength = Math.ceil(bitLength / 8);

                    currentMessage.signals.push({
                        name: signalName,
                        startBit: startBit,
                        startByte: startByte,
                        bitLength: bitLength,
                        length: byteLength,
                        endianness: endianness,
                        signed: isSigned,
                        scale: scale,
                        offset: offset,
                        unit: unit
                    });
                }
            }

            if (Object.keys(mapping).length === 0) {
                throw new Error('No valid messages found in DBC file');
            }

            return mapping;
        }

        function handleDBCFile(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('dbcInput').value = e.target.result;
                parseDBC();
            };
            reader.readAsText(file);
        }

        function normalizeHexKey(key) {
            // Convert any hex string format to "0xXXX" uppercase format
            let hex = key.trim().replace(/^0x/i, '');
            return '0x' + parseInt(hex, 16).toString(16).toUpperCase();
        }

        function showMappingStatus(message, type) {
            const statusDiv = document.getElementById('mappingStatus');
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            statusDiv.className = 'mapping-status';

            if (type === 'error') {
                statusDiv.style.background = '#3e1e1e';
                statusDiv.style.borderColor = '#f48771';
                statusDiv.style.color = '#f48771';
            } else {
                statusDiv.style.background = '#1e3a1e';
                statusDiv.style.borderColor = '#4ec9b0';
                statusDiv.style.color = '#4ec9b0';
            }
        }

        function clearMapping() {
            messageMapping = {};
            document.getElementById('mappingInput').value = '';
            document.getElementById('dbcInput').value = '';
            document.getElementById('mappingStatus').style.display = 'none';

            // Re-parse messages without mapping
            if (input.value.trim()) {
                parseMessages();
            }
        }

        function loadMappingExample() {
            const example = {
                "0x123": {
                    "name": "EngineData",
                    "signals": [
                        {
                            "name": "Temperature",
                            "startByte": 1,
                            "length": 1,
                            "offset": 30,
                            "scale": 1,
                            "endianness": "big",
                            "unit": "¬∞C"
                        },
                        {
                            "name": "RPM",
                            "startByte": 2,
                            "length": 1,
                            "offset": 0,
                            "scale": 1,
                            "endianness": "big",
                            "unit": "rpm"
                        }
                    ]
                },
                "0x456": {
                    "name": "SpeedData",
                    "signals": [
                        {
                            "name": "VehicleSpeed",
                            "startByte": 0,
                            "length": 2,
                            "offset": 0,
                            "scale": 0.01,
                            "endianness": "little",
                            "unit": "km/h"
                        }
                    ]
                }
            };

            document.getElementById('mappingInput').value = JSON.stringify(example, null, 2);
            applyMapping();
        }

        function decodeSignal(data, signal) {
            try {
                let rawValue;

                if (signal.bitLength && signal.startBit !== undefined) {
                    // Bit-level extraction for DBC signals
                    rawValue = extractBits(data, signal.startBit, signal.bitLength, signal.endianness === 'little');

                    // Handle signed values
                    if (signal.signed && rawValue >= (1 << (signal.bitLength - 1))) {
                        rawValue -= (1 << signal.bitLength);
                    }
                } else {
                    // Byte-level extraction for simple JSON mappings
                    const startByte = signal.startByte || 0;
                    const length = signal.length || 1;

                    if (startByte + length > data.length) {
                        return null;
                    }

                    const bytes = data.slice(startByte, startByte + length);

                    if (signal.endianness === 'little') {
                        rawValue = bytes.reduce((acc, byte, i) => acc + (byte << (8 * i)), 0);
                    } else {
                        // big endian (default)
                        rawValue = bytes.reduce((acc, byte) => (acc << 8) + byte, 0);
                    }
                }

                // Apply scale and offset
                const scale = signal.scale !== undefined ? signal.scale : 1;
                const offset = signal.offset !== undefined ? signal.offset : 0;
                const physicalValue = rawValue * scale + offset;

                // Format the output
                let displayValue;
                if (scale < 1 || physicalValue % 1 !== 0) {
                    displayValue = physicalValue.toFixed(2);
                } else {
                    displayValue = Math.round(physicalValue).toString();
                }

                if (signal.unit) {
                    displayValue += ' ' + signal.unit;
                }

                return displayValue;
            } catch (e) {
                return 'Error';
            }
        }

        function extractBits(data, startBit, bitLength, isLittleEndian) {
            // Convert byte array to bit array
            let bits = [];
            for (let i = 0; i < data.length; i++) {
                for (let j = 0; j < 8; j++) {
                    bits.push((data[i] >> j) & 1);
                }
            }

            let value = 0;
            if (isLittleEndian) {
                for (let i = 0; i < bitLength; i++) {
                    if (startBit + i < bits.length && bits[startBit + i]) {
                        value |= (1 << i);
                    }
                }
            } else {
                // Big endian bit ordering
                for (let i = 0; i < bitLength; i++) {
                    if (startBit + i < bits.length && bits[startBit + i]) {
                        value |= (1 << (bitLength - 1 - i));
                    }
                }
            }

            return value;
        }

        function getMessageMapping(message) {
            const msgIdHex = message.idHex;
            return messageMapping[msgIdHex] || null;
        }
    </script>
</body>
</html>
