<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BMX Track Game - Claude Code</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .back-link {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            transition: background 0.3s;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .title {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        button:hover {
            background: white;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: #667eea;
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #87CEEB;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        canvas.panning {
            cursor: grab;
        }

        canvas.panning:active {
            cursor: grabbing;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.6;
            max-width: 300px;
        }

        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.6;
            min-width: 200px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }

        .stat-label {
            opacity: 0.8;
        }

        .stat-value {
            font-weight: bold;
        }

        .speed-good {
            color: #4ade80;
        }

        .speed-medium {
            color: #fbbf24;
        }

        .speed-bad {
            color: #f87171;
        }

        .instructions {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 0.5rem 2rem;
            text-align: center;
            font-size: 0.9rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-header h2 {
            color: #667eea;
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: #333;
            transform: none;
        }

        .setting-group {
            margin-bottom: 1.5rem;
        }

        .setting-group label {
            display: block;
            color: #333;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .setting-group input[type="range"] {
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .setting-group input[type="number"] {
            width: 100%;
            padding: 0.5rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
        }

        .setting-info {
            display: flex;
            justify-content: space-between;
            color: #666;
            font-size: 0.9rem;
        }

        .button-group {
            display: flex;
            gap: 0.25rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 0.25rem;
            background: rgba(0, 0, 0, 0.2);
        }

        .button-group button {
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="../" class="back-link">‚Üê Back to Games</a>
            <div class="title">üèçÔ∏è BMX Track Game</div>
            <div class="controls">
                <div class="button-group">
                    <button id="freehandBtn" class="active">‚úèÔ∏è Freehand</button>
                    <button id="lineBtn">üìè Line</button>
                    <button id="splineBtn">„Ä∞Ô∏è Spline</button>
                    <button id="eraserBtn">üßπ Eraser</button>
                </div>
                <button id="undoBtn">‚Ü∂ Undo</button>
                <button id="playBtn">‚ñ∂Ô∏è Play</button>
                <button id="resetBtn">üîÑ Reset Rider</button>
                <button id="clearBtn">üóëÔ∏è Clear Track</button>
                <button id="settingsBtn">‚öôÔ∏è Physics</button>
                <button id="panBtn">‚úã Pan</button>
            </div>
        </div>

        <div class="instructions">
            <strong>How to play:</strong> Draw a track with Freehand/Line/Spline tools. Click Play to watch the rider attempt it. Master pumping through smooth transitions for speed! ‚Ä¢ Line/Spline: Click points, double-click or Enter to finish ‚Ä¢ Undo or Ctrl+Z to remove segments ‚Ä¢ Physics settings to adjust difficulty
        </div>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="info" id="info">
                <strong>üéÆ Controls:</strong><br>
                ‚Ä¢ Freehand: Drag to draw<br>
                ‚Ä¢ Line/Spline: Click points, double-click or Enter to finish<br>
                ‚Ä¢ Escape to cancel current line<br>
                ‚Ä¢ Undo button or Ctrl+Z<br>
                ‚Ä¢ Mouse wheel to zoom<br>
                ‚Ä¢ Middle-click or Pan to move<br>
                ‚Ä¢ Space to play/pause<br>
                <br>
                <strong>üèçÔ∏è Physics:</strong><br>
                ‚Ä¢ Pump through transitions for speed<br>
                ‚Ä¢ Smooth landings = boost<br>
                ‚Ä¢ Bad landings = crash
            </div>

            <div class="stats" id="stats">
                <div class="stat-row">
                    <span class="stat-label">Speed:</span>
                    <span class="stat-value" id="speedValue">0.0 m/s</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Distance:</span>
                    <span class="stat-value" id="distanceValue">0 m</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Air Time:</span>
                    <span class="stat-value" id="airTimeValue">0.0 s</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Status:</span>
                    <span class="stat-value" id="statusValue">Drawing</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Physics Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚öôÔ∏è Physics Settings</h2>
                <button class="close-btn" id="closeModal">&times;</button>
            </div>

            <div class="setting-group">
                <label for="gravitySlider">Gravity</label>
                <input type="range" id="gravitySlider" min="0.1" max="2" step="0.1" value="0.5">
                <div class="setting-info">
                    <span>Lower = Floatier</span>
                    <span id="gravityValue">0.5</span>
                    <span>Higher = Heavier</span>
                </div>
            </div>

            <div class="setting-group">
                <label for="speedSlider">Initial Speed</label>
                <input type="range" id="speedSlider" min="1" max="20" step="0.5" value="5">
                <div class="setting-info">
                    <span>Slower</span>
                    <span id="speedValue2">5.0</span>
                    <span>Faster</span>
                </div>
            </div>

            <div class="setting-group">
                <label for="pumpSlider">Pump Bonus (Speed Reward)</label>
                <input type="range" id="pumpSlider" min="0" max="1" step="0.05" value="0.3">
                <div class="setting-info">
                    <span>No Reward</span>
                    <span id="pumpValue">0.30</span>
                    <span>Big Reward</span>
                </div>
            </div>

            <div class="setting-group">
                <label for="crashSlider">Crash Threshold</label>
                <input type="range" id="crashSlider" min="5" max="30" step="1" value="15">
                <div class="setting-info">
                    <span>Fragile</span>
                    <span id="crashValue">15</span>
                    <span>Tough</span>
                </div>
            </div>

            <div class="setting-group">
                <label for="frictionSlider">Ground Friction</label>
                <input type="range" id="frictionSlider" min="0.9" max="1" step="0.01" value="0.99">
                <div class="setting-info">
                    <span>More Friction</span>
                    <span id="frictionValue">0.99</span>
                    <span>Less Friction</span>
                </div>
            </div>

            <div class="setting-group">
                <label for="airResistanceSlider">Air Resistance</label>
                <input type="range" id="airResistanceSlider" min="0.95" max="1" step="0.001" value="0.999">
                <div class="setting-info">
                    <span>More Drag</span>
                    <span id="airResistanceValue">0.999</span>
                    <span>Less Drag</span>
                </div>
            </div>

            <div class="setting-group">
                <label for="suspensionSlider">Suspension Damping</label>
                <input type="range" id="suspensionSlider" min="0" max="0.9" step="0.1" value="0.3">
                <div class="setting-info">
                    <span>Stiff</span>
                    <span id="suspensionValue">0.3</span>
                    <span>Soft</span>
                </div>
            </div>

            <div class="setting-group">
                <label for="bumpThresholdSlider">Bump Sensitivity</label>
                <input type="range" id="bumpThresholdSlider" min="0.05" max="0.5" step="0.05" value="0.2">
                <div class="setting-info">
                    <span>Sensitive</span>
                    <span id="bumpThresholdValue">0.20</span>
                    <span>Tolerant</span>
                </div>
            </div>

            <button id="resetSettingsBtn" style="width: 100%; margin-top: 1rem;">Reset to Defaults</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to fill container
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            redraw();
        }
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let mode = 'draw'; // 'draw', 'play', 'pan', 'erase'
        let drawMode = 'freehand'; // 'freehand', 'line', 'spline', 'eraser'
        let isPlaying = false;
        let trackSegments = []; // Array of segments, each segment is {points: [], type: 'freehand'|'line'|'spline'}
        let currentStroke = []; // Current drawing stroke
        let tempPoints = []; // Temporary points for line/spline mode
        let isErasing = false; // Track if currently erasing

        // Transform (camera/view)
        let transform = {
            scale: 1,
            translateX: canvas.width / 2,
            translateY: canvas.height / 2
        };

        // Rider physics
        let rider = {
            x: 0,
            y: -100,
            vx: 5, // horizontal velocity
            vy: 0, // vertical velocity
            rotation: 0, // rider angle
            isOnGround: false,
            groundContactPoint: null,
            totalDistance: 0,
            airTime: 0,
            lastGroundY: -100,
            crashed: false,
            size: 15, // Fixed size in world coordinates
            lastTrackAngle: 0 // For suspension
        };

        // Physics constants (now adjustable)
        let physics = {
            GRAVITY: 0.5,
            GROUND_FRICTION: 0.99,
            AIR_RESISTANCE: 0.999,
            PUMP_BONUS: 0.3,
            CRASH_THRESHOLD: 15,
            MIN_SPEED: 0.5,
            INITIAL_SPEED: 5,
            SUSPENSION_DAMPING: 0.3, // Suspension damping (0-1, higher = more damping)
            BUMP_THRESHOLD: 0.2 // Angle change threshold for bumps (radians)
        };

        // Default physics (for reset)
        const DEFAULT_PHYSICS = {
            GRAVITY: 0.5,
            GROUND_FRICTION: 0.99,
            AIR_RESISTANCE: 0.999,
            PUMP_BONUS: 0.3,
            CRASH_THRESHOLD: 15,
            MIN_SPEED: 0.5,
            INITIAL_SPEED: 5,
            SUSPENSION_DAMPING: 0.3,
            BUMP_THRESHOLD: 0.2
        };

        // Convert screen coordinates to world coordinates
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - transform.translateX) / transform.scale,
                y: (screenY - transform.translateY) / transform.scale
            };
        }

        // Convert world coordinates to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: worldX * transform.scale + transform.translateX,
                y: worldY * transform.scale + transform.translateY
            };
        }

        // Drawing functions
        function redraw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Save context and apply transform
            ctx.save();
            ctx.translate(transform.translateX, transform.translateY);
            ctx.scale(transform.scale, transform.scale);

            // Draw grid
            drawGrid();

            // Draw track
            drawTrack();

            // Draw current stroke (freehand mode)
            if (currentStroke.length > 0 && drawMode === 'freehand') {
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 4 / transform.scale;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.setLineDash([5 / transform.scale, 5 / transform.scale]);
                ctx.beginPath();
                ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
                for (let i = 1; i < currentStroke.length; i++) {
                    ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw temp points and preview for line/spline mode
            if (tempPoints.length > 0 && (drawMode === 'line' || drawMode === 'spline')) {
                // Draw points
                ctx.fillStyle = '#667eea';
                tempPoints.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4 / transform.scale, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw preview line/spline
                if (tempPoints.length >= 2) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 4 / transform.scale;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.setLineDash([5 / transform.scale, 5 / transform.scale]);
                    ctx.beginPath();

                    if (drawMode === 'spline') {
                        drawSpline(tempPoints);
                    } else {
                        ctx.moveTo(tempPoints[0].x, tempPoints[0].y);
                        for (let i = 1; i < tempPoints.length; i++) {
                            ctx.lineTo(tempPoints[i].x, tempPoints[i].y);
                        }
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw rider
            if (isPlaying || rider.totalDistance > 0) {
                drawRider();
            }

            // Restore context
            ctx.restore();
        }

        function drawGrid() {
            const gridSize = 50;
            const lineWidth = 1 / transform.scale;

            // Calculate visible bounds
            const topLeft = screenToWorld(0, 0);
            const bottomRight = screenToWorld(canvas.width, canvas.height);

            // Draw vertical lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = lineWidth;
            const startX = Math.floor(topLeft.x / gridSize) * gridSize;
            const endX = Math.ceil(bottomRight.x / gridSize) * gridSize;
            for (let x = startX; x <= endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, topLeft.y);
                ctx.lineTo(x, bottomRight.y);
                ctx.stroke();
            }

            // Draw horizontal lines
            const startY = Math.floor(topLeft.y / gridSize) * gridSize;
            const endY = Math.ceil(bottomRight.y / gridSize) * gridSize;
            for (let y = startY; y <= endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(topLeft.x, y);
                ctx.lineTo(bottomRight.x, y);
                ctx.stroke();
            }

            // Draw origin
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2 / transform.scale;
            ctx.beginPath();
            ctx.moveTo(-20, 0);
            ctx.lineTo(20, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(0, 20);
            ctx.stroke();
        }

        function drawTrack() {
            if (trackSegments.length === 0) return;

            // Draw track outline first
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 8 / transform.scale;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = 0.5;

            trackSegments.forEach(segment => {
                if (segment.points.length < 2) return;

                ctx.beginPath();
                if (segment.type === 'spline') {
                    drawSpline(segment.points);
                } else {
                    ctx.moveTo(segment.points[0].x, segment.points[0].y);
                    for (let i = 1; i < segment.points.length; i++) {
                        ctx.lineTo(segment.points[i].x, segment.points[i].y);
                    }
                }
                ctx.stroke();
            });

            ctx.globalAlpha = 1.0;

            // Draw track main line
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 6 / transform.scale;

            trackSegments.forEach(segment => {
                if (segment.points.length < 2) return;

                ctx.beginPath();
                if (segment.type === 'spline') {
                    drawSpline(segment.points);
                } else {
                    ctx.moveTo(segment.points[0].x, segment.points[0].y);
                    for (let i = 1; i < segment.points.length; i++) {
                        ctx.lineTo(segment.points[i].x, segment.points[i].y);
                    }
                }
                ctx.stroke();
            });
        }

        function drawSpline(points) {
            if (points.length < 2) return;

            ctx.moveTo(points[0].x, points[0].y);

            if (points.length === 2) {
                ctx.lineTo(points[1].x, points[1].y);
                return;
            }

            // Catmull-Rom spline
            for (let i = 0; i < points.length - 1; i++) {
                const p0 = points[Math.max(i - 1, 0)];
                const p1 = points[i];
                const p2 = points[i + 1];
                const p3 = points[Math.min(i + 2, points.length - 1)];

                const cp1x = p1.x + (p2.x - p0.x) / 6;
                const cp1y = p1.y + (p2.y - p0.y) / 6;
                const cp2x = p2.x - (p3.x - p1.x) / 6;
                const cp2y = p2.y - (p3.y - p1.y) / 6;

                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
            }
        }

        function drawRider() {
            const size = rider.size; // Use fixed size in world coordinates

            // Draw bike
            ctx.save();
            ctx.translate(rider.x, rider.y);
            ctx.rotate(rider.rotation);

            // Determine color based on status
            let bikeColor = '#000000';
            if (rider.crashed) {
                bikeColor = '#ef4444';
            } else if (rider.isOnGround) {
                bikeColor = '#3b82f6';
            } else {
                bikeColor = '#f59e0b';
            }

            // Bike frame
            ctx.strokeStyle = bikeColor;
            ctx.lineWidth = 3; // Fixed width in world coordinates
            ctx.beginPath();
            // Front triangle
            ctx.moveTo(-size, 0);
            ctx.lineTo(0, -size);
            ctx.lineTo(size, 0);
            ctx.stroke();

            // Wheels
            ctx.fillStyle = bikeColor;
            ctx.beginPath();
            ctx.arc(-size * 0.7, 0, size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(size * 0.7, 0, size * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Rider (simple stick figure)
            ctx.strokeStyle = bikeColor;
            ctx.lineWidth = 2; // Fixed width in world coordinates
            // Body
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(0, -size * 1.8);
            ctx.stroke();
            // Head
            ctx.beginPath();
            ctx.arc(0, -size * 2.2, size * 0.4, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        // Erase track segments near a world coordinate
        function eraseTrackAt(worldX, worldY, eraseRadius = 20) {
            let segmentsToRemove = [];

            trackSegments.forEach((segment, segIdx) => {
                let pointsToKeep = [];
                let hasGap = false;
                let gapStart = 0;

                segment.points.forEach((point, ptIdx) => {
                    const dist = Math.sqrt(
                        (point.x - worldX) ** 2 + (point.y - worldY) ** 2
                    );

                    if (dist > eraseRadius) {
                        if (hasGap && pointsToKeep.length - gapStart > 1) {
                            // We have a gap - need to split the segment
                            hasGap = false;
                        }
                        pointsToKeep.push(point);
                    } else {
                        if (pointsToKeep.length > 0 && !hasGap) {
                            hasGap = true;
                            gapStart = pointsToKeep.length;
                        }
                    }
                });

                // If we have very few points left, mark segment for removal
                if (pointsToKeep.length < 2) {
                    segmentsToRemove.push(segIdx);
                } else if (pointsToKeep.length !== segment.points.length) {
                    // Update segment with remaining points
                    segment.points = pointsToKeep;
                }
            });

            // Remove segments with too few points (in reverse order to maintain indices)
            for (let i = segmentsToRemove.length - 1; i >= 0; i--) {
                trackSegments.splice(segmentsToRemove[i], 1);
            }
        }

        // Track collision detection
        function findTrackSegmentAt(x, tolerance = 10) {
            let closestPoint = null;
            let closestDist = tolerance;
            let segmentIndex = -1;

            // Check all track segments
            trackSegments.forEach(segment => {
                const points = segment.points;
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];

                    // Only check segments where x is within range
                    if (x >= Math.min(p1.x, p2.x) - tolerance && x <= Math.max(p1.x, p2.x) + tolerance) {
                        // Find closest point on segment
                        const point = closestPointOnSegment(x, p1, p2);
                        const dist = Math.abs(x - point.x);

                        if (dist < closestDist) {
                            closestDist = dist;
                            closestPoint = point;
                            segmentIndex = i;
                        }
                    }
                }
            });

            return closestPoint ? { point: closestPoint, segmentIndex } : null;
        }

        function closestPointOnSegment(x, p1, p2) {
            // Find y on line segment at given x
            if (Math.abs(p2.x - p1.x) < 0.01) {
                // Vertical line
                return { x: p1.x, y: (p1.y + p2.y) / 2 };
            }

            const t = (x - p1.x) / (p2.x - p1.x);
            const clampedT = Math.max(0, Math.min(1, t));

            return {
                x: p1.x + clampedT * (p2.x - p1.x),
                y: p1.y + clampedT * (p2.y - p1.y),
                t: clampedT,
                p1: p1,
                p2: p2
            };
        }

        function getTrackAngle(p1, p2) {
            return Math.atan2(p2.y - p1.y, p2.x - p1.x);
        }

        // Physics update
        function updatePhysics(deltaTime = 1) {
            if (!isPlaying || rider.crashed) return;

            const prevY = rider.y;
            const prevVY = rider.vy;

            // Apply gravity
            rider.vy += physics.GRAVITY * deltaTime;

            // Apply velocity
            rider.x += rider.vx * deltaTime;
            rider.y += rider.vy * deltaTime;

            // Update total distance
            rider.totalDistance += Math.abs(rider.vx * deltaTime);

            // Check for track collision
            const trackCheck = findTrackSegmentAt(rider.x, 30);

            if (trackCheck && trackCheck.point) {
                const groundY = trackCheck.point.y;
                const distToGround = rider.y - groundY;

                // If rider is at or below track surface
                if (distToGround >= -5) {
                    rider.isOnGround = true;
                    rider.y = groundY;
                    rider.groundContactPoint = trackCheck.point;

                    // Calculate track angle
                    const p1 = trackCheck.point.p1;
                    const p2 = trackCheck.point.p2;
                    const trackAngle = getTrackAngle(p1, p2);

                    // Suspension: dampen small angle changes (bumps)
                    const angleChange = Math.abs(trackAngle - rider.lastTrackAngle);
                    if (angleChange < physics.BUMP_THRESHOLD && rider.isOnGround) {
                        // Apply suspension damping to smooth out small bumps
                        rider.vy *= (1 - physics.SUSPENSION_DAMPING);
                    }

                    rider.rotation = trackAngle;
                    rider.lastTrackAngle = trackAngle;

                    // Calculate landing impact
                    const impactSpeed = Math.abs(rider.vy);

                    // Check for crash (too fast vertical impact)
                    if (impactSpeed > physics.CRASH_THRESHOLD && rider.airTime > 0.1) {
                        rider.crashed = true;
                        rider.vx = 0;
                        rider.vy = 0;
                        updateStats();
                        return;
                    }

                    // Pumping mechanics - reward smooth transitions
                    const trackSlope = Math.sin(trackAngle);
                    const isDescending = trackSlope > 0; // Going downhill
                    const isAscending = trackSlope < 0; // Going uphill

                    // If transitioning from air to ground
                    if (rider.airTime > 0) {
                        // Good landing: rider's trajectory aligns with track
                        const velocityAngle = Math.atan2(rider.vy, rider.vx);
                        const angleDiff = Math.abs(velocityAngle - trackAngle);

                        if (angleDiff < 0.5) {
                            // Smooth landing = speed boost
                            rider.vx += physics.PUMP_BONUS * (1 - angleDiff / 0.5);
                        } else if (angleDiff > 1.5) {
                            // Bad landing = slowdown
                            rider.vx *= 0.7;
                        }

                        rider.airTime = 0;
                    }

                    // Pumping through transitions
                    if (isDescending) {
                        // Gain speed going down
                        rider.vx += Math.abs(trackSlope) * 0.2;
                    }

                    // Convert vertical velocity to horizontal based on slope
                    const slopeEffect = trackSlope * 0.5;
                    rider.vx += slopeEffect;

                    // Reset vertical velocity on ground
                    rider.vy = 0;

                    // Apply friction
                    rider.vx *= physics.GROUND_FRICTION;

                    // Follow track slope for velocity
                    rider.vy = rider.vx * trackSlope;

                    rider.lastGroundY = rider.y;
                } else {
                    // In the air
                    rider.isOnGround = false;
                    rider.airTime += deltaTime * 0.016; // Approximate seconds

                    // Air resistance
                    rider.vx *= physics.AIR_RESISTANCE;

                    // Update rotation based on velocity
                    rider.rotation = Math.atan2(rider.vy, rider.vx);
                }
            } else {
                // No track nearby - in air
                rider.isOnGround = false;
                rider.airTime += deltaTime * 0.016;
                rider.vx *= physics.AIR_RESISTANCE;
                rider.rotation = Math.atan2(rider.vy, rider.vx);
            }

            // Stop if too slow
            if (Math.abs(rider.vx) < physics.MIN_SPEED && rider.isOnGround) {
                rider.crashed = true;
                rider.vx = 0;
                rider.vy = 0;
            }

            // Update camera to follow rider
            if (isPlaying) {
                const targetX = canvas.width / 3 - rider.x * transform.scale;
                const targetY = canvas.height / 2 - rider.y * transform.scale;

                // Smooth camera movement
                transform.translateX += (targetX - transform.translateX) * 0.1;
                transform.translateY += (targetY - transform.translateY) * 0.1;
            }

            updateStats();
        }

        function updateStats() {
            const speed = Math.sqrt(rider.vx * rider.vx + rider.vy * rider.vy);
            const speedElem = document.getElementById('speedValue');
            speedElem.textContent = speed.toFixed(1) + ' m/s';

            // Color code speed
            if (speed > 10) {
                speedElem.className = 'stat-value speed-good';
            } else if (speed > 5) {
                speedElem.className = 'stat-value speed-medium';
            } else {
                speedElem.className = 'stat-value speed-bad';
            }

            document.getElementById('distanceValue').textContent = Math.floor(rider.totalDistance) + ' m';
            document.getElementById('airTimeValue').textContent = rider.airTime.toFixed(1) + ' s';

            let status = 'Drawing';
            if (isPlaying) {
                if (rider.crashed) {
                    status = 'üí• Crashed!';
                } else if (rider.isOnGround) {
                    status = 'üö¥ Riding';
                } else {
                    status = '‚úàÔ∏è Airborne';
                }
            }
            document.getElementById('statusValue').textContent = status;
        }

        // Animation loop
        let lastTime = Date.now();
        function animate() {
            const now = Date.now();
            const deltaTime = Math.min((now - lastTime) / 16, 2); // Cap at 2x speed
            lastTime = now;

            if (isPlaying) {
                updatePhysics(deltaTime);
            }

            redraw();
            requestAnimationFrame(animate);
        }

        // Mouse handling
        let isDrawing = false;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let lastWorldX = 0;
        let lastWorldY = 0;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            lastMouseX = mouseX;
            lastMouseY = mouseY;

            const world = screenToWorld(mouseX, mouseY);
            lastWorldX = world.x;
            lastWorldY = world.y;

            if (mode === 'draw' && !isPlaying) {
                if (drawMode === 'freehand') {
                    isDrawing = true;
                    currentStroke = [{ x: world.x, y: world.y }];
                } else if (drawMode === 'line' || drawMode === 'spline') {
                    // Add point to temp points
                    tempPoints.push({ x: world.x, y: world.y });
                    redraw();
                } else if (drawMode === 'eraser') {
                    isErasing = true;
                    eraseTrackAt(world.x, world.y);
                    redraw();
                }
            } else if (mode === 'pan' || e.button === 1) {
                isPanning = true;
                canvas.classList.add('panning');
                e.preventDefault();
            }
        });

        canvas.addEventListener('dblclick', (e) => {
            if (mode === 'draw' && !isPlaying && (drawMode === 'line' || drawMode === 'spline')) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const world = screenToWorld(mouseX, mouseY);

                // Add final point and finish the segment
                tempPoints.push({ x: world.x, y: world.y });

                if (tempPoints.length >= 2) {
                    trackSegments.push({
                        points: [...tempPoints],
                        type: drawMode
                    });
                    tempPoints = [];
                    redraw();
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (isDrawing && drawMode === 'freehand') {
                const world = screenToWorld(mouseX, mouseY);

                // Add point if moved enough
                const lastPoint = currentStroke[currentStroke.length - 1];
                const dist = Math.sqrt(
                    (world.x - lastPoint.x) ** 2 +
                    (world.y - lastPoint.y) ** 2
                );

                if (dist > 3) {
                    currentStroke.push({ x: world.x, y: world.y });
                    redraw();
                }
            } else if (isErasing && drawMode === 'eraser') {
                const world = screenToWorld(mouseX, mouseY);
                eraseTrackAt(world.x, world.y);
                redraw();
            } else if (isPanning) {
                const dx = mouseX - lastMouseX;
                const dy = mouseY - lastMouseY;
                transform.translateX += dx;
                transform.translateY += dy;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                redraw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDrawing && drawMode === 'freehand') {
                // Add current stroke to track segments
                if (currentStroke.length > 1) {
                    trackSegments.push({
                        points: [...currentStroke],
                        type: 'freehand'
                    });
                }
                currentStroke = [];
                isDrawing = false;
                redraw();
            }

            if (isErasing) {
                isErasing = false;
            }

            if (isPanning) {
                isPanning = false;
                canvas.classList.remove('panning');
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDrawing && drawMode === 'freehand') {
                if (currentStroke.length > 1) {
                    trackSegments.push({
                        points: [...currentStroke],
                        type: 'freehand'
                    });
                }
                currentStroke = [];
                isDrawing = false;
            }
            isErasing = false;
            isPanning = false;
            canvas.classList.remove('panning');
        });

        // Prevent middle-click scroll
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1) {
                e.preventDefault();
            }
        });

        // Zoom with mouse wheel
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Get world position before zoom
            const worldBefore = screenToWorld(mouseX, mouseY);

            // Zoom
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            const newScale = transform.scale * zoomFactor;

            // Clamp scale
            if (newScale >= 0.1 && newScale <= 5) {
                transform.scale = newScale;

                // Get world position after zoom
                const worldAfter = screenToWorld(mouseX, mouseY);

                // Adjust translation to keep mouse position stable
                transform.translateX += (worldAfter.x - worldBefore.x) * transform.scale;
                transform.translateY += (worldAfter.y - worldBefore.y) * transform.scale;

                redraw();
            }
        }, { passive: false });

        // Button controls - Drawing modes
        document.getElementById('freehandBtn').addEventListener('click', () => {
            mode = 'draw';
            drawMode = 'freehand';
            tempPoints = [];
            updateButtonStates();
            canvas.style.cursor = 'crosshair';
        });

        document.getElementById('lineBtn').addEventListener('click', () => {
            mode = 'draw';
            drawMode = 'line';
            tempPoints = [];
            updateButtonStates();
            canvas.style.cursor = 'crosshair';
        });

        document.getElementById('splineBtn').addEventListener('click', () => {
            mode = 'draw';
            drawMode = 'spline';
            tempPoints = [];
            updateButtonStates();
            canvas.style.cursor = 'crosshair';
        });

        document.getElementById('eraserBtn').addEventListener('click', () => {
            mode = 'draw';
            drawMode = 'eraser';
            tempPoints = [];
            updateButtonStates();
            canvas.style.cursor = 'not-allowed';
        });

        document.getElementById('panBtn').addEventListener('click', () => {
            mode = 'pan';
            tempPoints = [];
            updateButtonStates();
            canvas.style.cursor = 'grab';
        });

        // Undo button
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (trackSegments.length > 0) {
                trackSegments.pop();
                redraw();
            }
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            // Check if track has any segments with points
            let hasTrack = false;
            for (const segment of trackSegments) {
                if (segment.points.length >= 2) {
                    hasTrack = true;
                    break;
                }
            }

            if (!hasTrack) {
                alert('Draw a track first!');
                return;
            }

            isPlaying = !isPlaying;

            if (isPlaying) {
                document.getElementById('playBtn').textContent = '‚è∏Ô∏è Pause';

                // Reset rider if crashed or first time
                if (rider.crashed || rider.totalDistance === 0) {
                    resetRider();
                }
            } else {
                document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è Play';
            }

            updateButtonStates();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            resetRider();
            redraw();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('Clear the entire track?')) {
                trackSegments = [];
                currentStroke = [];
                tempPoints = [];
                resetRider();
                isPlaying = false;
                document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è Play';
                redraw();
            }
        });

        // Settings button
        document.getElementById('settingsBtn').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.add('active');
        });

        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.remove('active');
        });

        // Click outside modal to close
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') {
                document.getElementById('settingsModal').classList.remove('active');
            }
        });

        function resetRider() {
            // Find the leftmost track point to start from
            let startX = 0;
            let startY = -100;

            if (trackSegments.length > 0 && trackSegments[0].points.length > 0) {
                startX = trackSegments[0].points[0].x;
                startY = trackSegments[0].points[0].y - 50;
            }

            rider = {
                x: startX,
                y: startY,
                vx: physics.INITIAL_SPEED,
                vy: 0,
                rotation: 0,
                isOnGround: false,
                groundContactPoint: null,
                totalDistance: 0,
                airTime: 0,
                lastGroundY: startY,
                crashed: false,
                size: 15,
                lastTrackAngle: 0
            };

            updateStats();
        }

        function updateButtonStates() {
            // Drawing mode buttons
            document.getElementById('freehandBtn').classList.toggle('active', drawMode === 'freehand');
            document.getElementById('lineBtn').classList.toggle('active', drawMode === 'line');
            document.getElementById('splineBtn').classList.toggle('active', drawMode === 'spline');
            document.getElementById('eraserBtn').classList.toggle('active', drawMode === 'eraser');

            // Pan button
            document.getElementById('panBtn').classList.toggle('active', mode === 'pan');
        }

        // Physics settings sliders
        document.getElementById('gravitySlider').addEventListener('input', (e) => {
            physics.GRAVITY = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = physics.GRAVITY.toFixed(1);
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            physics.INITIAL_SPEED = parseFloat(e.target.value);
            document.getElementById('speedValue2').textContent = physics.INITIAL_SPEED.toFixed(1);
        });

        document.getElementById('pumpSlider').addEventListener('input', (e) => {
            physics.PUMP_BONUS = parseFloat(e.target.value);
            document.getElementById('pumpValue').textContent = physics.PUMP_BONUS.toFixed(2);
        });

        document.getElementById('crashSlider').addEventListener('input', (e) => {
            physics.CRASH_THRESHOLD = parseFloat(e.target.value);
            document.getElementById('crashValue').textContent = physics.CRASH_THRESHOLD.toFixed(0);
        });

        document.getElementById('frictionSlider').addEventListener('input', (e) => {
            physics.GROUND_FRICTION = parseFloat(e.target.value);
            document.getElementById('frictionValue').textContent = physics.GROUND_FRICTION.toFixed(2);
        });

        document.getElementById('airResistanceSlider').addEventListener('input', (e) => {
            physics.AIR_RESISTANCE = parseFloat(e.target.value);
            document.getElementById('airResistanceValue').textContent = physics.AIR_RESISTANCE.toFixed(3);
        });

        document.getElementById('suspensionSlider').addEventListener('input', (e) => {
            physics.SUSPENSION_DAMPING = parseFloat(e.target.value);
            document.getElementById('suspensionValue').textContent = physics.SUSPENSION_DAMPING.toFixed(1);
        });

        document.getElementById('bumpThresholdSlider').addEventListener('input', (e) => {
            physics.BUMP_THRESHOLD = parseFloat(e.target.value);
            document.getElementById('bumpThresholdValue').textContent = physics.BUMP_THRESHOLD.toFixed(2);
        });

        document.getElementById('resetSettingsBtn').addEventListener('click', () => {
            physics = { ...DEFAULT_PHYSICS };

            // Update sliders
            document.getElementById('gravitySlider').value = physics.GRAVITY;
            document.getElementById('gravityValue').textContent = physics.GRAVITY.toFixed(1);

            document.getElementById('speedSlider').value = physics.INITIAL_SPEED;
            document.getElementById('speedValue2').textContent = physics.INITIAL_SPEED.toFixed(1);

            document.getElementById('pumpSlider').value = physics.PUMP_BONUS;
            document.getElementById('pumpValue').textContent = physics.PUMP_BONUS.toFixed(2);

            document.getElementById('crashSlider').value = physics.CRASH_THRESHOLD;
            document.getElementById('crashValue').textContent = physics.CRASH_THRESHOLD.toFixed(0);

            document.getElementById('frictionSlider').value = physics.GROUND_FRICTION;
            document.getElementById('frictionValue').textContent = physics.GROUND_FRICTION.toFixed(2);

            document.getElementById('airResistanceSlider').value = physics.AIR_RESISTANCE;
            document.getElementById('airResistanceValue').textContent = physics.AIR_RESISTANCE.toFixed(3);

            document.getElementById('suspensionSlider').value = physics.SUSPENSION_DAMPING;
            document.getElementById('suspensionValue').textContent = physics.SUSPENSION_DAMPING.toFixed(1);

            document.getElementById('bumpThresholdSlider').value = physics.BUMP_THRESHOLD;
            document.getElementById('bumpThresholdValue').textContent = physics.BUMP_THRESHOLD.toFixed(2);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                document.getElementById('playBtn').click();
            } else if (e.code === 'Enter' && tempPoints.length >= 2 && (drawMode === 'line' || drawMode === 'spline')) {
                // Finish line/spline on Enter
                trackSegments.push({
                    points: [...tempPoints],
                    type: drawMode
                });
                tempPoints = [];
                redraw();
            } else if (e.code === 'Escape' && tempPoints.length > 0) {
                // Cancel current line/spline on Escape
                tempPoints = [];
                redraw();
            } else if (e.code === 'KeyZ' && e.ctrlKey && trackSegments.length > 0) {
                // Ctrl+Z for undo
                e.preventDefault();
                trackSegments.pop();
                redraw();
            }
        });

        // Initialize
        resizeCanvas();
        updateButtonStates();
        updateStats();
        animate();
    </script>
</body>
</html>
