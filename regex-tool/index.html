<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex Tool - Claude Code Tools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2d2d30;
            padding: 15px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5em;
            color: #ffffff;
        }

        .header a {
            color: #569cd6;
            text-decoration: none;
            font-size: 0.9em;
        }

        .header a:hover {
            text-decoration: underline;
        }

        .container {
            flex: 1;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .main-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 20px;
        }

        .section-title {
            font-size: 1.1em;
            color: #9cdcfe;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pattern-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .regex-delimiter {
            font-size: 1.5em;
            color: #ce9178;
            font-weight: bold;
        }

        #pattern-input {
            flex: 1;
            background: #1e1e1e;
            border: 2px solid #3e3e42;
            border-radius: 4px;
            padding: 12px;
            color: #ce9178;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            outline: none;
        }

        #pattern-input:focus {
            border-color: #569cd6;
        }

        #pattern-input.error {
            border-color: #f48771;
        }

        .flags-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .flag-option {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
        }

        .flag-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .flag-option label {
            cursor: pointer;
            color: #d4d4d4;
        }

        .flag-option .flag-desc {
            color: #858585;
            font-size: 0.85em;
        }

        #test-string {
            width: 100%;
            min-height: 150px;
            background: #1e1e1e;
            border: 2px solid #3e3e42;
            border-radius: 4px;
            padding: 12px;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            outline: none;
            line-height: 1.6;
        }

        #test-string:focus {
            border-color: #569cd6;
        }

        .results-container {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            min-height: 100px;
        }

        .match-count {
            color: #4ec9b0;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3e3e42;
        }

        .match-item {
            background: #2d2d30;
            border-left: 3px solid #4ec9b0;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 3px;
        }

        .match-text {
            color: #ce9178;
            font-family: 'Courier New', monospace;
            margin-bottom: 5px;
        }

        .match-info {
            font-size: 0.85em;
            color: #858585;
        }

        .capture-groups {
            margin-top: 8px;
            padding-left: 15px;
        }

        .capture-group {
            color: #dcdcaa;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin: 3px 0;
        }

        .highlighted-text {
            white-space: pre-wrap;
            line-height: 1.6;
        }

        .highlight {
            background: #4ec9b044;
            border-bottom: 2px solid #4ec9b0;
            padding: 2px 0;
        }

        .error-message {
            color: #f48771;
            background: #f4877122;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #f48771;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            max-height: calc(100vh - 100px);
        }

        .examples-section {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 15px;
        }

        .example-item {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .example-item:hover {
            border-color: #569cd6;
        }

        .example-title {
            color: #9cdcfe;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .example-pattern {
            color: #ce9178;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .example-desc {
            color: #858585;
            font-size: 0.85em;
        }

        .cheatsheet {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 15px;
        }

        .cheat-category {
            margin-bottom: 15px;
        }

        .cheat-category-title {
            color: #dcdcaa;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .cheat-item {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
            font-size: 0.85em;
        }

        .cheat-symbol {
            color: #ce9178;
            font-family: 'Courier New', monospace;
            min-width: 60px;
        }

        .cheat-meaning {
            color: #858585;
        }

        .no-matches {
            color: #858585;
            text-align: center;
            padding: 20px;
        }

        /* Pattern Generator Styles */
        .generator-section {
            background: #2d2d30;
            border: 2px solid #569cd6;
        }

        .generator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .generator-mode-toggle {
            background: #569cd6;
            color: #ffffff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .generator-mode-toggle:hover {
            background: #4a8bc2;
        }

        #sample-text {
            width: 100%;
            min-height: 120px;
            background: #1e1e1e;
            border: 2px solid #3e3e42;
            border-radius: 4px;
            padding: 12px;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            outline: none;
            line-height: 1.8;
            user-select: text;
        }

        #sample-text:focus {
            border-color: #569cd6;
        }

        .sample-text-display {
            width: 100%;
            min-height: 120px;
            background: #1e1e1e;
            border: 2px solid #3e3e42;
            border-radius: 4px;
            padding: 12px;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
            cursor: text;
            user-select: none;
        }

        .sample-text-display:focus {
            border-color: #569cd6;
            outline: none;
        }

        .selectable-word {
            display: inline;
            cursor: pointer;
            padding: 2px 0;
            border-radius: 2px;
            transition: background 0.2s;
        }

        .selectable-word:hover {
            background: #3e3e4288;
        }

        .selectable-word.selected {
            background: #569cd644;
            border-bottom: 2px solid #569cd6;
            font-weight: bold;
        }

        .generator-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .generator-button {
            background: #4ec9b0;
            color: #1e1e1e;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .generator-button:hover {
            background: #42a890;
        }

        .generator-button.secondary {
            background: #3e3e42;
            color: #d4d4d4;
        }

        .generator-button.secondary:hover {
            background: #4e4e52;
        }

        .generator-button:disabled {
            background: #3e3e42;
            color: #858585;
            cursor: not-allowed;
        }

        .generator-info {
            background: #569cd622;
            border-left: 3px solid #569cd6;
            padding: 12px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 0.9em;
            color: #9cdcfe;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            background: #1e1e1e;
            padding: 5px;
            border-radius: 6px;
            border: 1px solid #3e3e42;
        }

        .mode-option {
            flex: 1;
            background: transparent;
            color: #d4d4d4;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .mode-option:hover {
            background: #2d2d30;
        }

        .mode-option.active {
            background: #569cd6;
            color: #ffffff;
            font-weight: bold;
        }

        .dual-selection-container {
            display: none;
        }

        .dual-selection-container.active {
            display: block;
        }

        .token-selection-container {
            display: block;
        }

        .token-selection-container.hidden {
            display: none;
        }

        .selection-step {
            background: #1e1e1e;
            border: 2px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .selection-step.active {
            border-color: #4ec9b0;
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .step-number {
            background: #569cd6;
            color: #ffffff;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .step-title {
            color: #9cdcfe;
            font-weight: bold;
        }

        .step-description {
            color: #858585;
            font-size: 0.85em;
            margin-bottom: 10px;
        }

        .context-display {
            background: #252526;
            border: 2px solid #3e3e42;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
            cursor: text;
            user-select: text;
            min-height: 100px;
        }

        .context-display.selecting {
            border-color: #4ec9b0;
            box-shadow: 0 0 0 2px #4ec9b044;
        }

        .context-highlight {
            background: #569cd644;
            border-bottom: 2px solid #569cd6;
            padding: 2px 0;
        }

        .changing-bit-highlight {
            background: #4ec9b088;
            border-bottom: 2px solid #4ec9b0;
            font-weight: bold;
            padding: 2px 0;
        }

        .selection-info {
            background: #2d2d30;
            border-left: 3px solid #4ec9b0;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.85em;
            color: #d4d4d4;
        }

        .selection-info code {
            background: #1e1e1e;
            color: #4ec9b0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .generated-pattern-display {
            background: #1e1e1e;
            border: 2px solid #4ec9b0;
            border-radius: 4px;
            padding: 12px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            color: #4ec9b0;
            font-size: 16px;
            display: none;
        }

        .generated-pattern-display.visible {
            display: block;
        }

        .pattern-label {
            font-size: 0.85em;
            color: #858585;
            margin-bottom: 5px;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                max-height: none;
            }
        }

        @media (max-width: 600px) {
            .pattern-input-group {
                flex-direction: column;
                align-items: stretch;
            }

            .flags-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç Regex Tool</h1>
        <a href="../">‚Üê Back to Tools</a>
    </div>

    <div class="container">
        <div class="main-panel">
            <!-- Pattern Generator Section -->
            <div class="section generator-section">
                <div class="generator-header">
                    <div class="section-title">‚ú® Pattern Generator</div>
                    <button class="generator-mode-toggle" id="toggle-mode" onclick="toggleGeneratorMode()">
                        Switch to Manual Entry
                    </button>
                </div>

                <div id="generator-mode">
                    <!-- Mode Selector -->
                    <div class="mode-selector">
                        <button class="mode-option" id="token-mode-btn" onclick="switchToTokenMode()">
                            Token Selection
                        </button>
                        <button class="mode-option active" id="dual-mode-btn" onclick="switchToDualMode()">
                            Dual Selection (Context-Based)
                        </button>
                    </div>

                    <!-- Dual Selection Mode -->
                    <div id="dual-selection-container" class="dual-selection-container active">
                        <textarea id="dual-sample-text" placeholder="Paste your sample text with context here...
Example:
Order ID: 12345 Date: 2023-10-01
Order ID: 67890 Date: 2023-10-02
Order ID: 54321 Date: 2023-10-03">Order ID: 12345 Date: 2023-10-01
Order ID: 67890 Date: 2023-10-02
Order ID: 54321 Date: 2023-10-03</textarea>

                        <!-- Step 1: Select Context -->
                        <div class="selection-step" id="context-step">
                            <div class="step-header">
                                <div class="step-number">1</div>
                                <div class="step-title">Select Context Block</div>
                            </div>
                            <div class="step-description">
                                Select the entire block of text that contains both changing and unchanging parts
                            </div>
                            <div class="generator-controls">
                                <button class="generator-button" onclick="startContextSelection()" id="context-select-btn">
                                    Select Context
                                </button>
                                <button class="generator-button secondary" onclick="clearDualSelections()">
                                    Clear All
                                </button>
                            </div>
                            <div id="context-selection-info" class="selection-info" style="display: none;">
                                Context selected: <code id="context-text-display"></code>
                            </div>
                        </div>

                        <!-- Step 2: Select Changing Bit -->
                        <div class="selection-step" id="changing-bit-step">
                            <div class="step-header">
                                <div class="step-number">2</div>
                                <div class="step-title">Select Changing Bit</div>
                            </div>
                            <div class="step-description">
                                Within the context, select the part that changes (e.g., numbers, dates, specific words)
                            </div>
                            <div class="generator-controls">
                                <button class="generator-button" onclick="startChangingBitSelection()" id="changing-bit-select-btn" disabled>
                                    Select Changing Bit
                                </button>
                            </div>
                            <div id="changing-bit-selection-info" class="selection-info" style="display: none;">
                                Changing bit selected: <code id="changing-bit-text-display"></code>
                            </div>
                        </div>

                        <!-- Generate Button -->
                        <div class="generator-controls">
                            <button class="generator-button" onclick="generateDualPattern()" id="generate-dual-btn" disabled>
                                Generate Pattern
                            </button>
                        </div>

                        <div id="dual-generated-pattern-display" class="generated-pattern-display">
                            <div class="pattern-label">Generated Pattern:</div>
                            <div id="dual-generated-pattern-text"></div>
                        </div>

                        <div class="generator-info">
                            <strong>How to use Dual Selection Mode:</strong>
                            <ol style="margin: 8px 0 0 20px; line-height: 1.6;">
                                <li>Paste sample text with repeating patterns (like log entries, structured data, etc.)</li>
                                <li>Click "Select Context" and highlight the entire block containing both changing and fixed parts</li>
                                <li>Click "Select Changing Bit" and highlight just the part that varies (numbers, dates, etc.)</li>
                                <li>Click "Generate Pattern" to create a regex that captures the changing bit with context</li>
                                <li>The pattern will include surrounding text for context and capture only the variable part</li>
                            </ol>
                            <div style="margin-top: 10px; font-size: 0.9em;">
                                <strong>Example:</strong> If you select "Order ID: 12345 Date: 2023-10-01" as context and "12345" as the changing bit,
                                it will generate a pattern like <code style="background: #1e1e1e; padding: 2px 6px; border-radius: 3px;">Order ID: (\d+)</code>
                            </div>
                        </div>
                    </div>

                    <!-- Token Selection Mode -->
                    <div id="token-selection-container" class="token-selection-container hidden">
                        <textarea id="sample-text" placeholder="Paste your sample text here...">Contact us at support@example.com
Call: (555) 123-4567
Visit: https://example.com
Date: 12/15/2024</textarea>

                        <div class="generator-controls">
                            <button class="generator-button" onclick="enableSelectionMode()">
                                Select Text to Extract
                            </button>
                            <button class="generator-button secondary" onclick="clearSelections()">
                                Clear Selections
                            </button>
                        </div>

                        <div id="selection-display" style="display: none;">
                            <div class="sample-text-display" id="selectable-display"></div>
                            <div class="generator-controls">
                                <button class="generator-button" onclick="generatePattern()">
                                    Generate Pattern
                                </button>
                                <button class="generator-button secondary" onclick="backToEdit()">
                                    Back to Edit
                                </button>
                            </div>
                        </div>

                        <div id="generated-pattern-display" class="generated-pattern-display">
                            <div class="pattern-label">Generated Pattern:</div>
                            <div id="generated-pattern-text"></div>
                        </div>

                        <div class="generator-info">
                            <strong>How to use Token Selection Mode:</strong>
                            <ol style="margin: 8px 0 0 20px; line-height: 1.6;">
                                <li>Paste or type sample text containing patterns you want to extract</li>
                                <li>Click "Select Text to Extract" to enter selection mode</li>
                                <li>Click on the parts of the text you want to match (like emails, phone numbers, etc.)</li>
                                <li>Click "Generate Pattern" to create a regex that matches your selections</li>
                                <li>The generated pattern will appear below and in the pattern input</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pattern Input Section -->
            <div class="section">
                <div class="section-title">Regular Expression Pattern</div>
                <div class="pattern-input-group">
                    <span class="regex-delimiter">/</span>
                    <input type="text" id="pattern-input" placeholder="Enter your regex pattern..." value="(\w+)@(\w+\.\w+)">
                    <span class="regex-delimiter">/</span>
                </div>
                <div class="flags-group">
                    <div class="flag-option">
                        <input type="checkbox" id="flag-g" checked>
                        <label for="flag-g">g <span class="flag-desc">(global)</span></label>
                    </div>
                    <div class="flag-option">
                        <input type="checkbox" id="flag-i">
                        <label for="flag-i">i <span class="flag-desc">(case-insensitive)</span></label>
                    </div>
                    <div class="flag-option">
                        <input type="checkbox" id="flag-m">
                        <label for="flag-m">m <span class="flag-desc">(multiline)</span></label>
                    </div>
                    <div class="flag-option">
                        <input type="checkbox" id="flag-s">
                        <label for="flag-s">s <span class="flag-desc">(dotAll)</span></label>
                    </div>
                </div>
            </div>

            <!-- Test String Section -->
            <div class="section">
                <div class="section-title">Test String</div>
                <textarea id="test-string" placeholder="Enter text to test against your pattern...">Contact us at support@example.com or sales@company.org
You can also reach admin@test.net for assistance.</textarea>
            </div>

            <!-- Results Section -->
            <div class="section">
                <div class="section-title">Match Results</div>
                <div class="results-container" id="results"></div>
            </div>

            <!-- Highlighted Text Section -->
            <div class="section">
                <div class="section-title">Highlighted Matches</div>
                <div class="results-container">
                    <div class="highlighted-text" id="highlighted-text"></div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <!-- Examples Section -->
            <div class="examples-section">
                <div class="section-title">Common Patterns</div>
                <div class="example-item" onclick="loadExample('email')">
                    <div class="example-title">Email Address</div>
                    <div class="example-pattern">(\w+)@(\w+\.\w+)</div>
                    <div class="example-desc">Matches basic email addresses</div>
                </div>
                <div class="example-item" onclick="loadExample('phone')">
                    <div class="example-title">Phone Number</div>
                    <div class="example-pattern">\(?(\d{3})\)?[-.\s]?(\d{3})[-.\s]?(\d{4})</div>
                    <div class="example-desc">Matches US phone numbers</div>
                </div>
                <div class="example-item" onclick="loadExample('url')">
                    <div class="example-title">URL</div>
                    <div class="example-pattern">https?://[\w\-.]+(:\d+)?(/[\w\-./]*)?</div>
                    <div class="example-desc">Matches HTTP/HTTPS URLs</div>
                </div>
                <div class="example-item" onclick="loadExample('date')">
                    <div class="example-title">Date (MM/DD/YYYY)</div>
                    <div class="example-pattern">(\d{1,2})/(\d{1,2})/(\d{4})</div>
                    <div class="example-desc">Matches dates in MM/DD/YYYY format</div>
                </div>
                <div class="example-item" onclick="loadExample('hex')">
                    <div class="example-title">Hex Color</div>
                    <div class="example-pattern">#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})</div>
                    <div class="example-desc">Matches hex color codes</div>
                </div>
                <div class="example-item" onclick="loadExample('ip')">
                    <div class="example-title">IP Address</div>
                    <div class="example-pattern">\b(\d{1,3}\.){3}\d{1,3}\b</div>
                    <div class="example-desc">Matches IPv4 addresses</div>
                </div>
            </div>

            <!-- Cheatsheet Section -->
            <div class="cheatsheet">
                <div class="section-title">Quick Reference</div>

                <div class="cheat-category">
                    <div class="cheat-category-title">Character Classes</div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">\d</span>
                        <span class="cheat-meaning">Any digit (0-9)</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">\w</span>
                        <span class="cheat-meaning">Word character (a-z, A-Z, 0-9, _)</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">\s</span>
                        <span class="cheat-meaning">Whitespace</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">.</span>
                        <span class="cheat-meaning">Any character</span>
                    </div>
                </div>

                <div class="cheat-category">
                    <div class="cheat-category-title">Quantifiers</div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">*</span>
                        <span class="cheat-meaning">0 or more</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">+</span>
                        <span class="cheat-meaning">1 or more</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">?</span>
                        <span class="cheat-meaning">0 or 1</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">{n}</span>
                        <span class="cheat-meaning">Exactly n times</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">{n,m}</span>
                        <span class="cheat-meaning">Between n and m times</span>
                    </div>
                </div>

                <div class="cheat-category">
                    <div class="cheat-category-title">Anchors</div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">^</span>
                        <span class="cheat-meaning">Start of line</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">$</span>
                        <span class="cheat-meaning">End of line</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">\b</span>
                        <span class="cheat-meaning">Word boundary</span>
                    </div>
                </div>

                <div class="cheat-category">
                    <div class="cheat-category-title">Groups</div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">(...)</span>
                        <span class="cheat-meaning">Capture group</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">(?:...)</span>
                        <span class="cheat-meaning">Non-capturing group</span>
                    </div>
                    <div class="cheat-item">
                        <span class="cheat-symbol">|</span>
                        <span class="cheat-meaning">OR operator</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const patternInput = document.getElementById('pattern-input');
        const testString = document.getElementById('test-string');
        const resultsDiv = document.getElementById('results');
        const highlightedDiv = document.getElementById('highlighted-text');
        const flagCheckboxes = {
            g: document.getElementById('flag-g'),
            i: document.getElementById('flag-i'),
            m: document.getElementById('flag-m'),
            s: document.getElementById('flag-s')
        };

        // Example patterns
        const examples = {
            email: {
                pattern: '(\\w+)@(\\w+\\.\\w+)',
                test: `Contact us at support@example.com or sales@company.org
You can also reach admin@test.net for assistance.`,
                flags: { g: true, i: false, m: false, s: false }
            },
            phone: {
                pattern: '\\(?(\\d{3})\\)?[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})',
                test: `Call us at (555) 123-4567 or 555.234.5678
International: 555-345-6789`,
                flags: { g: true, i: false, m: false, s: false }
            },
            url: {
                pattern: 'https?://[\\w\\-.]+(:\\d+)?(/[\\w\\-./?#&=]*)?',
                test: `Visit our website at https://example.com
API endpoint: http://api.example.com:8080/v1/users
Documentation: https://docs.example.com/guide`,
                flags: { g: true, i: false, m: false, s: false }
            },
            date: {
                pattern: '(\\d{1,2})/(\\d{1,2})/(\\d{4})',
                test: `Event dates:
- Conference: 12/15/2024
- Workshop: 3/5/2025
- Deadline: 06/30/2025`,
                flags: { g: true, i: false, m: false, s: false }
            },
            hex: {
                pattern: '#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})',
                test: `Primary color: #FF5733
Secondary: #33FF57
Accent: #3357FF
Background: #f0f
Border: #333`,
                flags: { g: true, i: false, m: false, s: false }
            },
            ip: {
                pattern: '\\b(\\d{1,3}\\.){3}\\d{1,3}\\b',
                test: `Server addresses:
- Production: 192.168.1.100
- Staging: 10.0.0.50
- Database: 172.16.254.1`,
                flags: { g: true, i: false, m: false, s: false }
            }
        };

        function getFlags() {
            let flags = '';
            if (flagCheckboxes.g.checked) flags += 'g';
            if (flagCheckboxes.i.checked) flags += 'i';
            if (flagCheckboxes.m.checked) flags += 'm';
            if (flagCheckboxes.s.checked) flags += 's';
            return flags;
        }

        function testRegex() {
            const pattern = patternInput.value;
            const text = testString.value;
            const flags = getFlags();

            resultsDiv.innerHTML = '';
            highlightedDiv.innerHTML = '';

            if (!pattern) {
                resultsDiv.innerHTML = '<div class="no-matches">Enter a regex pattern to start</div>';
                highlightedDiv.textContent = text;
                patternInput.classList.remove('error');
                return;
            }

            try {
                const regex = new RegExp(pattern, flags);
                patternInput.classList.remove('error');

                const matches = [...text.matchAll(new RegExp(pattern, flags.includes('g') ? flags : flags + 'g'))];

                if (matches.length === 0) {
                    resultsDiv.innerHTML = '<div class="no-matches">No matches found</div>';
                    highlightedDiv.textContent = text;
                    return;
                }

                // Display match count
                const countDiv = document.createElement('div');
                countDiv.className = 'match-count';
                countDiv.textContent = `Found ${matches.length} match${matches.length !== 1 ? 'es' : ''}`;
                resultsDiv.appendChild(countDiv);

                // Display each match
                matches.forEach((match, index) => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match-item';

                    const matchText = document.createElement('div');
                    matchText.className = 'match-text';
                    matchText.textContent = match[0];
                    matchDiv.appendChild(matchText);

                    const matchInfo = document.createElement('div');
                    matchInfo.className = 'match-info';
                    matchInfo.textContent = `Match ${index + 1} at position ${match.index}`;
                    matchDiv.appendChild(matchInfo);

                    // Display capture groups
                    if (match.length > 1) {
                        const captureDiv = document.createElement('div');
                        captureDiv.className = 'capture-groups';
                        for (let i = 1; i < match.length; i++) {
                            if (match[i] !== undefined) {
                                const groupDiv = document.createElement('div');
                                groupDiv.className = 'capture-group';
                                groupDiv.textContent = `Group ${i}: ${match[i]}`;
                                captureDiv.appendChild(groupDiv);
                            }
                        }
                        matchDiv.appendChild(captureDiv);
                    }

                    resultsDiv.appendChild(matchDiv);
                });

                // Highlight matches in text
                let highlightedText = text;
                const sortedMatches = [...matches].sort((a, b) => b.index - a.index);

                sortedMatches.forEach(match => {
                    const before = highlightedText.substring(0, match.index);
                    const matchText = highlightedText.substring(match.index, match.index + match[0].length);
                    const after = highlightedText.substring(match.index + match[0].length);
                    highlightedText = before + `<span class="highlight">${matchText}</span>` + after;
                });

                highlightedDiv.innerHTML = highlightedText;

            } catch (error) {
                patternInput.classList.add('error');
                resultsDiv.innerHTML = `<div class="error-message">Invalid regex: ${error.message}</div>`;
                highlightedDiv.textContent = text;
            }
        }

        function loadExample(exampleKey) {
            const example = examples[exampleKey];
            if (!example) return;

            patternInput.value = example.pattern;
            testString.value = example.test;

            Object.keys(flagCheckboxes).forEach(flag => {
                flagCheckboxes[flag].checked = example.flags[flag] || false;
            });

            testRegex();
        }

        // Add event listeners
        patternInput.addEventListener('input', testRegex);
        testString.addEventListener('input', testRegex);
        Object.values(flagCheckboxes).forEach(checkbox => {
            checkbox.addEventListener('change', testRegex);
        });

        // Initial test
        testRegex();

        // Pattern Generator functionality
        let selectedTexts = [];
        let generatorActive = true;

        function toggleGeneratorMode() {
            const toggleBtn = document.getElementById('toggle-mode');
            const generatorMode = document.getElementById('generator-mode');

            if (generatorActive) {
                generatorMode.style.display = 'none';
                toggleBtn.textContent = 'Switch to Pattern Generator';
                generatorActive = false;
            } else {
                generatorMode.style.display = 'block';
                toggleBtn.textContent = 'Switch to Manual Entry';
                generatorActive = true;
            }
        }

        function enableSelectionMode() {
            const sampleText = document.getElementById('sample-text');
            const selectionDisplay = document.getElementById('selection-display');
            const selectableDisplay = document.getElementById('selectable-display');

            sampleText.style.display = 'none';
            selectionDisplay.style.display = 'block';

            // Convert text to selectable elements
            const text = sampleText.value;
            renderSelectableText(text);
        }

        function backToEdit() {
            const sampleText = document.getElementById('sample-text');
            const selectionDisplay = document.getElementById('selection-display');

            sampleText.style.display = 'block';
            selectionDisplay.style.display = 'none';
            selectedTexts = [];
        }

        function renderSelectableText(text) {
            const selectableDisplay = document.getElementById('selectable-display');
            selectableDisplay.innerHTML = '';

            // Split text into tokens (words, punctuation, whitespace, etc.)
            const tokens = text.split(/(\s+|[.,;:!?()[\]{}'"<>@#$%^&*+=\-_/\\|~`])/);

            tokens.forEach((token, index) => {
                if (token.length === 0) return;

                if (token.trim().length > 0 && !/^[\s]+$/.test(token)) {
                    // Create clickable element for non-whitespace tokens
                    const span = document.createElement('span');
                    span.className = 'selectable-word';
                    span.textContent = token;
                    span.dataset.index = index;
                    span.dataset.token = token;
                    span.onclick = function() {
                        this.classList.toggle('selected');
                        updateSelectedTexts();
                    };
                    selectableDisplay.appendChild(span);
                } else {
                    // Preserve whitespace
                    const textNode = document.createTextNode(token);
                    selectableDisplay.appendChild(textNode);
                }
            });
        }

        function updateSelectedTexts() {
            const selected = document.querySelectorAll('.selectable-word.selected');
            selectedTexts = Array.from(selected).map(el => el.dataset.token);
        }

        function clearSelections() {
            const selected = document.querySelectorAll('.selectable-word.selected');
            selected.forEach(el => el.classList.remove('selected'));
            selectedTexts = [];

            const generatedDisplay = document.getElementById('generated-pattern-display');
            generatedDisplay.classList.remove('visible');
        }

        function generatePattern() {
            if (selectedTexts.length === 0) {
                alert('Please select some text first!');
                return;
            }

            // Analyze the selected texts and generate a pattern
            const pattern = analyzeAndGeneratePattern(selectedTexts);

            // Display the generated pattern
            const generatedDisplay = document.getElementById('generated-pattern-display');
            const generatedText = document.getElementById('generated-pattern-text');
            generatedText.textContent = pattern;
            generatedDisplay.classList.add('visible');

            // Update the pattern input field
            patternInput.value = pattern;

            // Copy sample text to test string
            const sampleText = document.getElementById('sample-text').value;
            testString.value = sampleText;

            // Run the test
            testRegex();
        }

        function analyzeAndGeneratePattern(texts) {
            // If only one selection, analyze it deeply
            if (texts.length === 1) {
                return analyzeToken(texts[0]);
            }

            // Multiple selections - try to find common pattern
            // First check if they're all the same type
            const patterns = texts.map(t => analyzeToken(t));
            const uniquePatterns = [...new Set(patterns)];

            if (uniquePatterns.length === 1) {
                // All same type, use that pattern
                return uniquePatterns[0];
            }

            // Different types - create alternation pattern or generic pattern
            // Try to find common structure
            const commonPattern = findCommonPattern(texts);
            if (commonPattern) {
                return commonPattern;
            }

            // Fall back to OR pattern
            return '(' + texts.map(escapeRegex).join('|') + ')';
        }

        function analyzeToken(token) {
            // Email pattern
            if (/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(token)) {
                return '([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})';
            }

            // Phone number patterns
            if (/^\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}$/.test(token)) {
                return '\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}';
            }

            // URL pattern
            if (/^https?:\/\/.+/.test(token)) {
                return 'https?://[\\w\\-.]+(:\\d+)?(/[\\w\\-./?#&=]*)?';
            }

            // Date patterns (MM/DD/YYYY or similar)
            if (/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$/.test(token)) {
                const separator = token.match(/[\/\-]/)[0];
                return '\\d{1,2}' + escapeRegex(separator) + '\\d{1,2}' + escapeRegex(separator) + '\\d{2,4}';
            }

            // Time pattern (HH:MM or HH:MM:SS)
            if (/^\d{1,2}:\d{2}(:\d{2})?$/.test(token)) {
                return '\\d{1,2}:\\d{2}(:\\d{2})?';
            }

            // IP address
            if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(token)) {
                return '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}';
            }

            // Hex color
            if (/^#[0-9A-Fa-f]{3,6}$/.test(token)) {
                return '#[0-9A-Fa-f]{3,6}';
            }

            // Number (integer or decimal)
            if (/^-?\d+(\.\d+)?$/.test(token)) {
                if (token.includes('.')) {
                    return '-?\\d+\\.\\d+';
                }
                return '-?\\d+';
            }

            // Word (letters only)
            if (/^[a-zA-Z]+$/.test(token)) {
                // Check if it's all uppercase, lowercase, or mixed
                if (token === token.toUpperCase()) {
                    return '[A-Z]+';
                } else if (token === token.toLowerCase()) {
                    return '[a-z]+';
                } else {
                    return '[a-zA-Z]+';
                }
            }

            // Alphanumeric
            if (/^[a-zA-Z0-9]+$/.test(token)) {
                return '[a-zA-Z0-9]+';
            }

            // Word characters (including underscore)
            if (/^\w+$/.test(token)) {
                return '\\w+';
            }

            // Default: escape and match literally, but try to generalize
            return escapeRegex(token);
        }

        function findCommonPattern(texts) {
            // Check if all texts have similar structure
            const structures = texts.map(t => getStructure(t));
            const firstStructure = structures[0];

            // If all have the same structure, use that
            if (structures.every(s => s === firstStructure)) {
                return analyzeToken(texts[0]);
            }

            // Try to find common length
            const lengths = texts.map(t => t.length);
            const avgLength = Math.round(lengths.reduce((a, b) => a + b) / lengths.length);
            const lengthVariance = Math.max(...lengths) - Math.min(...lengths);

            if (lengthVariance <= 2) {
                // Similar lengths, might be same type
                const structure = getStructure(texts[0]);
                return structure;
            }

            return null;
        }

        function getStructure(text) {
            // Return a pattern representing the structure
            return text.split('').map(char => {
                if (/\d/.test(char)) return '\\d';
                if (/[a-z]/i.test(char)) return '\\w';
                if (/\s/.test(char)) return '\\s';
                return escapeRegex(char);
            }).join('');
        }

        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Dual Selection Mode functionality
        let dualModeActive = true;
        let contextSelection = null;
        let changingBitSelection = null;
        let isSelectingContext = false;
        let isSelectingChangingBit = false;
        let contextSelectionHandler = null;
        let changingBitSelectionHandler = null;

        function switchToTokenMode() {
            document.getElementById('token-mode-btn').classList.add('active');
            document.getElementById('dual-mode-btn').classList.remove('active');
            document.getElementById('dual-selection-container').classList.remove('active');
            document.getElementById('token-selection-container').classList.remove('hidden');
            dualModeActive = false;
        }

        function switchToDualMode() {
            document.getElementById('token-mode-btn').classList.remove('active');
            document.getElementById('dual-mode-btn').classList.add('active');
            document.getElementById('dual-selection-container').classList.add('active');
            document.getElementById('token-selection-container').classList.add('hidden');
            dualModeActive = true;
        }

        function startContextSelection() {
            const textarea = document.getElementById('dual-sample-text');
            const contextBtn = document.getElementById('context-select-btn');

            // If already selecting, cancel
            if (isSelectingContext && contextSelectionHandler) {
                cancelContextSelection();
                return;
            }

            // Enable selection mode
            isSelectingContext = true;
            isSelectingChangingBit = false;

            // Update button to show cancel option
            const originalText = contextBtn.textContent;
            contextBtn.textContent = 'Cancel Selection';
            contextBtn.classList.add('secondary');

            // Add visual feedback
            textarea.classList.add('selecting-context');
            textarea.style.borderColor = '#4ec9b0';
            textarea.style.boxShadow = '0 0 0 2px #4ec9b044';

            // Show instructions
            const step = document.getElementById('context-step');
            let instructionDiv = step.querySelector('.selection-instruction');
            if (!instructionDiv) {
                instructionDiv = document.createElement('div');
                instructionDiv.className = 'selection-instruction';
                instructionDiv.style.cssText = 'background: #4ec9b044; padding: 10px; border-radius: 4px; margin-top: 10px; color: #4ec9b0; font-weight: bold;';
                step.insertBefore(instructionDiv, step.querySelector('.generator-controls').nextSibling);
            }
            instructionDiv.textContent = 'üëÜ Select the context block in the text area above, then release your mouse';

            // Listen for mouseup event to capture selection
            const handleSelection = () => {
                const selectedText = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);

                if (selectedText && selectedText.trim().length > 0) {
                    contextSelection = {
                        text: selectedText,
                        start: textarea.selectionStart,
                        end: textarea.selectionEnd
                    };

                    // Update UI
                    document.getElementById('context-text-display').textContent =
                        selectedText.length > 50 ? selectedText.substring(0, 50) + '...' : selectedText;
                    document.getElementById('context-selection-info').style.display = 'block';
                    document.getElementById('select-changing-btn').disabled = false;
                    document.getElementById('context-step').classList.add('active');

                    // Clear changing bit selection if any
                    changingBitSelection = null;
                    document.getElementById('changing-bit-selection-info').style.display = 'none';
                    document.getElementById('changing-bit-step').classList.remove('active');
                    document.getElementById('generate-dual-btn').disabled = true;

                    // Remove selection mode
                    isSelectingContext = false;
                    textarea.classList.remove('selecting-context');
                    textarea.style.borderColor = '';
                    textarea.style.boxShadow = '';
                    contextBtn.textContent = 'Select Context';
                    contextBtn.classList.remove('secondary');
                    if (instructionDiv) {
                        instructionDiv.remove();
                    }

                    // Remove event listener
                    textarea.removeEventListener('mouseup', handleSelection);
                    contextSelectionHandler = null;
                }
            };

            // Store handler reference
            contextSelectionHandler = handleSelection;

            // Attach event listener
            textarea.addEventListener('mouseup', handleSelection);

            // Focus textarea
            textarea.focus();
        }

        function cancelContextSelection() {
            const textarea = document.getElementById('dual-sample-text');
            const contextBtn = document.getElementById('context-select-btn');
            const step = document.getElementById('context-step');
            const instructionDiv = step.querySelector('.selection-instruction');

            // Remove selection mode
            isSelectingContext = false;
            textarea.classList.remove('selecting-context');
            textarea.style.borderColor = '';
            textarea.style.boxShadow = '';
            contextBtn.textContent = 'Select Context';
            contextBtn.classList.remove('secondary');
            if (instructionDiv) {
                instructionDiv.remove();
            }

            // Remove event listener
            if (contextSelectionHandler) {
                textarea.removeEventListener('mouseup', contextSelectionHandler);
                contextSelectionHandler = null;
            }
        }

        function startChangingBitSelection() {
            if (!contextSelection) {
                alert('Please select the context first!');
                return;
            }

            const textarea = document.getElementById('dual-sample-text');
            const changingBtn = document.getElementById('changing-bit-select-btn');

            // If already selecting, cancel
            if (isSelectingChangingBit && changingBitSelectionHandler) {
                cancelChangingBitSelection();
                return;
            }

            // Enable selection mode
            isSelectingChangingBit = true;
            isSelectingContext = false;

            // Update button to show cancel option
            const originalText = changingBtn.textContent;
            changingBtn.textContent = 'Cancel Selection';
            changingBtn.classList.add('secondary');

            // Add visual feedback
            textarea.style.borderColor = '#9cdcfe';
            textarea.style.boxShadow = '0 0 0 2px #9cdcfe44';

            // Show instructions
            const step = document.getElementById('changing-bit-step');
            let instructionDiv = step.querySelector('.selection-instruction');
            if (!instructionDiv) {
                instructionDiv = document.createElement('div');
                instructionDiv.className = 'selection-instruction';
                instructionDiv.style.cssText = 'background: #9cdcfe44; padding: 10px; border-radius: 4px; margin-top: 10px; color: #9cdcfe; font-weight: bold;';
                step.insertBefore(instructionDiv, step.querySelector('.generator-controls').nextSibling);
            }
            instructionDiv.innerHTML = 'üëÜ Select ONLY the changing part within your context<br/><small>Context: "' +
                (contextSelection.text.length > 60 ? contextSelection.text.substring(0, 60) + '...' : contextSelection.text) + '"</small>';

            // Set selection to context range to help user
            textarea.setSelectionRange(contextSelection.start, contextSelection.end);

            // Listen for mouseup event to capture selection
            const handleSelection = () => {
                const selectedText = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);
                const selectionStart = textarea.selectionStart;
                const selectionEnd = textarea.selectionEnd;

                if (selectedText && selectedText.trim().length > 0) {
                    // Verify that the changing bit is within the context
                    if (selectionStart >= contextSelection.start && selectionEnd <= contextSelection.end) {
                        // Ensure it's not the exact same as context
                        if (selectedText === contextSelection.text) {
                            // Show warning but don't block
                            instructionDiv.innerHTML = '‚ö†Ô∏è You selected the same text as context. Please select ONLY the changing part.<br/><small>Try again or click the button to cancel.</small>';
                            instructionDiv.style.background = '#f4877144';
                            instructionDiv.style.color = '#f48771';
                            return; // Don't save, wait for another selection
                        }

                        changingBitSelection = {
                            text: selectedText,
                            start: selectionStart,
                            end: selectionEnd,
                            relativeStart: selectionStart - contextSelection.start,
                            relativeEnd: selectionEnd - contextSelection.start
                        };

                        // Update UI
                        document.getElementById('changing-bit-text-display').textContent =
                            selectedText.length > 50 ? selectedText.substring(0, 50) + '...' : selectedText;
                        document.getElementById('changing-bit-selection-info').style.display = 'block';
                        document.getElementById('changing-bit-step').classList.add('active');
                        document.getElementById('generate-dual-btn').disabled = false;

                        // Remove selection mode
                        isSelectingChangingBit = false;
                        textarea.style.borderColor = '';
                        textarea.style.boxShadow = '';
                        changingBtn.textContent = 'Select Changing Bit';
                        changingBtn.classList.remove('secondary');
                        if (instructionDiv) {
                            instructionDiv.remove();
                        }

                        // Remove event listener
                        textarea.removeEventListener('mouseup', handleSelection);
                        changingBitSelectionHandler = null;
                    } else {
                        // Show error
                        instructionDiv.innerHTML = '‚ùå Selection must be within the context!<br/><small>Context range: characters ' +
                            contextSelection.start + '-' + contextSelection.end + ', your selection: ' +
                            selectionStart + '-' + selectionEnd + '</small>';
                        instructionDiv.style.background = '#f4877144';
                        instructionDiv.style.color = '#f48771';
                    }
                }
            };

            // Store handler reference
            changingBitSelectionHandler = handleSelection;

            // Attach event listener
            textarea.addEventListener('mouseup', handleSelection);

            // Focus textarea
            textarea.focus();
        }

        function cancelChangingBitSelection() {
            const textarea = document.getElementById('dual-sample-text');
            const changingBtn = document.getElementById('changing-bit-select-btn');
            const step = document.getElementById('changing-bit-step');
            const instructionDiv = step.querySelector('.selection-instruction');

            // Remove selection mode
            isSelectingChangingBit = false;
            textarea.style.borderColor = '';
            textarea.style.boxShadow = '';
            changingBtn.textContent = 'Select Changing Bit';
            changingBtn.classList.remove('secondary');
            if (instructionDiv) {
                instructionDiv.remove();
            }

            // Remove event listener
            if (changingBitSelectionHandler) {
                textarea.removeEventListener('mouseup', changingBitSelectionHandler);
                changingBitSelectionHandler = null;
            }
        }

        function clearDualSelections() {
            // Cancel any active selections
            if (isSelectingContext) {
                cancelContextSelection();
            }
            if (isSelectingChangingBit) {
                cancelChangingBitSelection();
            }

            // Clear stored selections
            contextSelection = null;
            changingBitSelection = null;
            document.getElementById('context-selection-info').style.display = 'none';
            document.getElementById('changing-bit-selection-info').style.display = 'none';
            document.getElementById('context-step').classList.remove('active');
            document.getElementById('changing-bit-step').classList.remove('active');
            document.getElementById('changing-bit-select-btn').disabled = true;
            document.getElementById('generate-dual-btn').disabled = true;
            document.getElementById('dual-generated-pattern-display').classList.remove('visible');
        }

        function generateDualPattern() {
            if (!contextSelection || !changingBitSelection) {
                alert('Please select both context and changing bit first!');
                return;
            }

            const context = contextSelection.text;
            const changingBit = changingBitSelection.text;
            const relativeStart = changingBitSelection.relativeStart;
            const relativeEnd = changingBitSelection.relativeEnd;

            // Get the parts before, during, and after the changing bit
            const before = context.substring(0, relativeStart);
            const after = context.substring(relativeEnd);

            // Analyze the changing bit to determine its pattern
            const changingBitPattern = analyzeChangingBit(changingBit);

            // Build the full pattern
            let pattern = '';

            // Add before part (escaped)
            if (before.trim().length > 0) {
                pattern += escapeRegex(before);
            }

            // Add capture group for changing bit
            pattern += '(' + changingBitPattern + ')';

            // Add after part (escaped) - but only include relevant context
            // We'll try to be smart about how much context to include
            if (after.trim().length > 0) {
                // Take up to the next whitespace or special character, or first few characters
                const afterContext = getRelevantContext(after);
                if (afterContext.length > 0) {
                    pattern += escapeRegex(afterContext);
                }
            }

            // Display the generated pattern
            document.getElementById('dual-generated-pattern-text').textContent = pattern;
            document.getElementById('dual-generated-pattern-display').classList.add('visible');

            // Update the main pattern input
            patternInput.value = pattern;

            // Copy sample text to test string
            testString.value = document.getElementById('dual-sample-text').value;

            // Enable global and multiline flags for better matching
            flagCheckboxes.g.checked = true;
            flagCheckboxes.m.checked = true;

            // Run the test
            testRegex();

            // Scroll to results
            setTimeout(() => {
                document.getElementById('results').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        }

        function analyzeChangingBit(text) {
            // Email pattern
            if (/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(text)) {
                return '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}';
            }

            // Phone number patterns
            if (/^\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}$/.test(text)) {
                return '\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}';
            }

            // URL pattern
            if (/^https?:\/\/.+/.test(text)) {
                return 'https?://[\\w\\-./?#&=]+';
            }

            // ISO Date (YYYY-MM-DD)
            if (/^\d{4}-\d{2}-\d{2}$/.test(text)) {
                return '\\d{4}-\\d{2}-\\d{2}';
            }

            // Date patterns (MM/DD/YYYY or similar)
            if (/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$/.test(text)) {
                const separator = text.match(/[\/\-]/)[0];
                return '\\d{1,2}' + escapeRegex(separator) + '\\d{1,2}' + escapeRegex(separator) + '\\d{2,4}';
            }

            // Time pattern (HH:MM or HH:MM:SS)
            if (/^\d{1,2}:\d{2}(:\d{2})?$/.test(text)) {
                return '\\d{1,2}:\\d{2}(:\\d{2})?';
            }

            // IP address
            if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(text)) {
                return '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}';
            }

            // Hex color
            if (/^#[0-9A-Fa-f]{3,6}$/.test(text)) {
                return '#[0-9A-Fa-f]{3,6}';
            }

            // Decimal number
            if (/^-?\d+\.\d+$/.test(text)) {
                const parts = text.split('.');
                const intDigits = parts[0].replace('-', '').length;
                const decDigits = parts[1].length;
                return '-?\\d+\\.\\d+';
            }

            // Integer
            if (/^-?\d+$/.test(text)) {
                const digitCount = text.replace('-', '').length;
                // Use exact digit count if reasonable, otherwise use +
                if (digitCount <= 10) {
                    return '-?\\d{' + digitCount + '}';
                }
                return '-?\\d+';
            }

            // Word (letters only)
            if (/^[a-zA-Z]+$/.test(text)) {
                const wordLength = text.length;
                // Check case patterns
                if (text === text.toUpperCase()) {
                    return '[A-Z]+';
                } else if (text === text.toLowerCase()) {
                    return '[a-z]+';
                } else {
                    // Mixed case - check if it's title case
                    if (/^[A-Z][a-z]*$/.test(text)) {
                        return '[A-Z][a-z]*';
                    }
                    return '[a-zA-Z]+';
                }
            }

            // Alphanumeric (no special chars)
            if (/^[a-zA-Z0-9]+$/.test(text)) {
                return '[a-zA-Z0-9]+';
            }

            // Word characters (including underscore)
            if (/^\w+$/.test(text)) {
                return '\\w+';
            }

            // Complex pattern with mixed characters - try to find structure
            const structure = analyzeStructure(text);
            if (structure) {
                return structure;
            }

            // Default: match the exact length with any character
            return '.{' + text.length + '}';
        }

        function analyzeStructure(text) {
            // Build a pattern based on character types
            let pattern = '';
            let i = 0;

            while (i < text.length) {
                const char = text[i];
                let charType = getCharType(char);
                let count = 1;

                // Count consecutive characters of the same type
                while (i + count < text.length && getCharType(text[i + count]) === charType) {
                    count++;
                }

                // Build pattern segment
                if (charType === 'digit') {
                    pattern += '\\d';
                } else if (charType === 'letter') {
                    if (char === char.toUpperCase()) {
                        pattern += '[A-Z]';
                    } else {
                        pattern += '[a-z]';
                    }
                } else if (charType === 'space') {
                    pattern += '\\s';
                } else if (charType === 'word') {
                    pattern += '\\w';
                } else {
                    pattern += escapeRegex(char);
                }

                // Add quantifier if more than one
                if (count > 1) {
                    if (count === 2) {
                        pattern += pattern.substring(pattern.length - (pattern.endsWith(']') ? 5 : 2));
                    } else {
                        pattern += '{' + count + '}';
                    }
                }

                i += count;
            }

            return pattern;
        }

        function getCharType(char) {
            if (/\d/.test(char)) return 'digit';
            if (/[a-zA-Z]/.test(char)) return 'letter';
            if (/\s/.test(char)) return 'space';
            if (/\w/.test(char)) return 'word';
            return 'other';
        }

        function getRelevantContext(afterText) {
            // Return relevant context after the changing bit
            // We want to include enough to disambiguate but not too much

            // If there's a space, take everything before it
            const spaceIndex = afterText.indexOf(' ');
            if (spaceIndex > 0 && spaceIndex < 20) {
                return afterText.substring(0, spaceIndex);
            }

            // If there's a newline, take everything before it
            const newlineIndex = afterText.indexOf('\n');
            if (newlineIndex > 0 && newlineIndex < 20) {
                return afterText.substring(0, newlineIndex);
            }

            // Take first few characters if they're not spaces
            const firstPart = afterText.substring(0, Math.min(10, afterText.length));
            if (firstPart.trim().length > 0) {
                return firstPart;
            }

            return '';
        }
    </script>
</body>
</html>
